# 数组

## [LCR 075. 数组的相对排序](https://leetcode.cn/problems/0H97ZC/)

1. > 给定两个数组，`arr1` 和 `arr2`，
   >
   > - `arr2` 中的元素各不相同
   > - `arr2` 中的每个元素都出现在 `arr1` 中
   >
   > 对 `arr1` 中的元素进行排序，使 `arr1` 中项的相对顺序和 `arr2` 中的相对顺序相同。未在 `arr2` 中出现过的元素需要按照升序放在 `arr1` 的末尾。

2. ```cpp
   class Solution {
   public:
       vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
           // 用哈希表记录arr2中每个元素的下标
           unordered_map<int, int> indexMap;
           for (int i = 0; i < arr2.size(); ++i) {
               indexMap[arr2[i]] = i;
           }
           
           // 自定义比较函数，首先按照arr2中的相对顺序排序，然后未在arr2中出现的元素按照升序排列
           auto customSort = [&](int a, int b) {
               if (indexMap.find(a) != indexMap.end() && indexMap.find(b) != indexMap.end()) {
                   return indexMap[a] < indexMap[b]; // 按照arr2中的相对顺序排序
               } else if (indexMap.find(a) != indexMap.end()) {
                   return true; // a在arr2中，b不在arr2中，将a放在b之前,就是可以放a
               } else if (indexMap.find(b) != indexMap.end()) {
                   return false; // b在arr2中，a不在arr2中，将b放在a之前
               } else {
                   return a < b; // 都不在arr2中，按照升序排列
               }
           };
           
           // 使用自定义比较函数对arr1进行排序
           sort(arr1.begin(), arr1.end(), customSort);
           
           return arr1;
       }
   };
   ```

3. ```cpp
   vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
       vector<int> hash(1001);
       for (int num : arr1) {
           hash[num]++;
       }
   
       	// 这一步真的巧妙啊！
       int index = 0;
       for (int num : arr2) {
           while (hash[num]-- > 0) {
               arr1[index++] = num;
           }
       }
   
       // num就是数字，所以是从小到大。
       for (int num = 0; num < hash.size(); num++) {
           while (hash[num]-- > 0) {
               arr1[index++] = num;
           }
       }
   
       return arr1;
   }
   ```

   



# 链表



## 自己写的链表demo

1. ```cpp
   struct ListNode {
        int val;
       ListNode *next;
       ListNode() : val(0), next(nullptr) {}
        ListNode(int x) : val(x), next(nullptr) {}
        ListNode(int x, ListNode *next) : val(x), next(next) {}
    };
   
    int main() {
        ListNode* head = new ListNode(4);
       ListNode* p = head;
   
        for (int i = 0; i < 5; i++) {
            ListNode* q = new ListNode(i + 1);
            p->next = q;
            p = p->next;
        }
         p = head;
        while (p) {
            cout << p->val << "-->";
            p = p->next;
        }
        return 0;
    }
    
   ```

2. ![image-20240317200431671](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240317200431671.png) 



## 给定一个数组vector，还有k，问是否存在两个数的和使得目标和是k，如果是就输出true

1. ```cpp
   #include <vector>
   #include <unordered_set>
   
   using namespace std;
   
   bool hasSum(vector<int>& nums, int k) {
       unordered_set<int> seen;
       for (int num : nums) {
           int complement = k - num;
           if (seen.count(complement)) {
               return true;
           }
           seen.insert(num);
       }
       return false;
   }
   
   ```

2. 

## [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

1. 可以设置一个虚拟节点`dummy`

2. ![image-20240317193142544](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedundefinedimage-20240317193142544.png) 

3. ```cpp
   class Solution {
   public:
       ListNode* removeElements(ListNode* head, int val) {
           ListNode* dummy = new ListNode(0);
           dummy->next = head;
           ListNode* cur = dummy;
           while (cur->next != NULL) {
               if (cur->next->val == val) {
                   ListNode* temp = cur->next;
                   cur->next = cur->next->next;
                   delete temp;
               } else {
                   cur = cur->next;
               }
           }
           head = dummy->next;
           delete dummy;
           return head;
       }
   };
   ```



## [5两两交换链表的结点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

1. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240317195439448.png" alt="image-20240317195439448" style="zoom:50%;" /> 

2. 主要步骤

   ![image-20240317195545629](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240317195545629.png) 

3. ```cpp
   class Solution {
   public:
       ListNode* swapPairs(ListNode* head) {
           ListNode* dummy = new ListNode(0);
           dummy->next = head;
           ListNode* cur = dummy;
           while (cur->next && cur->next->next) {
               ListNode* tmp = cur->next;
               ListNode* tmp1 = cur->next->next->next;
   
               cur->next = cur->next->next;
               cur->next->next = tmp;
               cur->next->next->next = tmp1;
               cur = cur->next->next;
           }
           return dummy->next;
       }
   };
   ```



## [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

1. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedundefinedimage-20240317201756160.png" alt="image-20240317201756160" style="zoom:50%;" /> 

2. ```cpp
   ListNode* removeNthFromEnd(ListNode* head, int n) {
       if (head == nullptr || n <= 0) // 边界情况处理
           return nullptr;
   
       ListNode dummy(0);  // 这里创建的是一个对象
       dummy.next = head;
       ListNode *slow = &dummy;
       ListNode *fast = &dummy;
   
       // 将 fast 指针向前移动 n+1 步
       for (int i = 0; i < n + 1; ++i) {
           if (fast == nullptr) // 如果链表长度小于 n+1，则直接返回头结点
               return head;
           fast = fast->next;
       }
   
       // 同时移动 slow 和 fast 指针，直到 fast 指针到达链表尾部
       while (fast != nullptr) {
           slow = slow->next;
           fast = fast->next;
       }
   
       // 删除倒数第 n 个节点
       ListNode *temp = slow->next;
       slow->next = slow->next->next;
       delete temp;
   
       return dummy.next;
   }
   ```

3. 递归方法

   ```cpp
   #include <iostream>
   
   struct ListNode {
       int val;
       ListNode *next;
       ListNode(int x) : val(x), next(nullptr) {}
   };
   
   // 辅助函数，用于计算链表长度
   int getLength(ListNode* head) {
       int length = 0;
       while (head != nullptr) {
           ++length;
           head = head->next;
       }
       return length;
   }
   
   // 递归函数，用于删除倒数第 n 个节点
   ListNode* removeNthFromEndRecursive(ListNode* head, int n, int& count) {
       // 边界情况处理，当链表为空或者n为0时，直接返回头结点
       if (head == nullptr || n == 0) {
           return head;
       }
   
       // 递归到链表末尾，返回nullptr，count表示当前节点是倒数第几个节点
       if (head->next == nullptr) {
           ++count;
           // 如果当前节点是倒数第n个节点，删除该节点并返回nullptr
           if (count == n) {
               delete head;
               return nullptr;
           }
           return head;
       }
   
       // 递归调用，删除倒数第n个节点
       head->next = removeNthFromEndRecursive(head->next, n, count);
   
       // 每次递归返回前，计数器+1
       ++count;
   
       // 如果当前节点是倒数第n个节点，删除该节点并返回下一个节点
       if (count == n) {
           ListNode* temp = head->next;
           delete head;
           return temp;
       }
   
       return head;
   }
   
   ListNode* removeNthFromEnd(ListNode* head, int n) {
       int count = 0;
       // 调用递归函数
       return removeNthFromEndRecursive(head, n, count);
   }
   
   // 辅助函数，用于打印链表
   void printList(ListNode* head) {
       while (head != nullptr) {
           std::cout << head->val << " ";
           head = head->next;
       }
       std::cout << std::endl;
   }
   
   int main() {
       // 创建示例链表：1 -> 2 -> 3 -> 4 -> 5
       ListNode *head = new ListNode(1);
       head->next = new ListNode(2);
       head->next->next = new ListNode(3);
       head->next->next->next = new ListNode(4);
       head->next->next->next->next = new ListNode(5);
   
       std::cout << "Original List: ";
       printList(head);
   
       int n = 2; // 要删除的倒数第 n 个节点
       head = removeNthFromEnd(head, n);
   
       std::cout << "List after removing " << n << "th node from end: ";
       printList(head);
   
       // 释放内存
       while (head != nullptr) {
           ListNode *temp = head;
           head = head->next;
           delete temp;
       }
   
       return 0;
   }
   
   ```

   

## [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

1. 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。

2. ```cpp
   class Solution {
   public:
       ListNode* deleteDuplicates(ListNode* head) {
           if (head == nullptr || head->next == nullptr) {
               return head; // 如果链表为空或只有一个节点，则直接返回原链表
           }
           
           ListNode* current = head;
           while (current->next) {
               if (current->val == current->next->val) {
                   ListNode* temp = current->next;
                   current->next = current->next->next; // 跳过重复的节点
                   delete temp; // 删除重复的节点
               } else {
                   current = current->next; // 继续遍历链表
               }	
           }
           
           return head;
       }
   };
   ```

3. 自己写的

   ```cpp
   class Solution {
   public:
       ListNode* deleteDuplicates(ListNode* head) {
           if (!head || head->next == nullptr) return head;
           // 现在至少有两个结点了
           ListNode* cur = head;
           while (cur->next) {
               ListNode* tmp = cur->next;
               if (cur->val == tmp->val) {
                   cur->next = tmp->next;
                   delete(tmp);
               } else {
                   cur = cur->next;
               }
           }
           return head;
       }
   };
   ```




## [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

1. 注意比较这一题和上一道题目的异同点，这一题是，把所有的一连串的都给删除了，上一题是还剩下一个。

2. <img src="../myNotes/h5200/images/image-20240329113429301.png" alt="image-20240329113429301" style="zoom:50%;" />

3. ```cpp
   class Solution {
   public:
       ListNode* deleteDuplicates(ListNode* head) {
           if (!head || head->next == nullptr) {
               return head;
           }
           ListNode* dummy = new ListNode(0);
           dummy->next = head;
           ListNode* cur = dummy;
   
           while (cur->next && cur->next->next) {
               if (cur->next->val == cur->next->next->val) { // 要使用if循环就得在while里面判断空指针。
                   int the_val = cur->next->val;
                   ListNode* p = cur->next;
                   while (p && p->val == the_val) {
                       p = p->next;
                   }
                   cur->next = p;
               } else { // 当前节点的后两个值不一样，cur向后移动一个
                   cur = cur->next;
               }
           }
           return dummy->next;
       }
   
   };
   ```

4. <img src="../myNotes/h5200/images/image-20240329113634140.png" alt="image-20240329113634140" style="zoom:33%;" />



## [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

1. ```cpp
   class Solution {
   private:
       int num[100010];
   public:
       bool isPalindrome(ListNode* head) {
           // 开一个数组
           if (!head || head->next == nullptr) {
               return true;
           }
           ListNode* cur = head;
           int index = 0;
           while (cur) {
               num[index++] = cur->val;
               cur = cur->next;
           }
   
           for (int i = 0; i < index; i++) {
               if (num[i] != num[index - 1 - i]) return false;
           }
           return true;
       }
   };
   ```





## [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

- <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240329134458686.png" alt="image-20240329134458686" style="zoom:50%;" />

- ```cpp
  class Solution {
  public:
      ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
          if (!headA || !headB) return nullptr;
  
          // 计算链表长度和尾节点
          int lenA = getLength(headA);
          int lenB = getLength(headB);
  
          ListNode *tailA = getTail(headA);
          ListNode *tailB = getTail(headB);
  
          // 如果尾节点不同，说明不相交
          if (tailA != tailB) return nullptr;
  
          ListNode *curA = headA;
          ListNode *curB = headB;
  
          // 长链表先移动差值个节点
          if (lenA > lenB) {
              for (int i = 0; i < lenA - lenB; ++i) {
                  curA = curA->next;
              }
          } else {
              for (int i = 0; i < lenB - lenA; ++i) {
                  curB = curB->next;
              }
          }
  
          // 同时遍历两个链表，找到第一个相交节点
          while (curA != curB) {
              curA = curA->next;
              curB = curB->next;
          }
  
          return curA; // 返回相交节点或nullptr
      }
  
      // 获取链表长度
      int getLength(ListNode *head) {
          int len = 0;
          while (head) {
              len++;
              head = head->next;
          }
          return len;
      }
  
      // 获取链表尾节点
      ListNode *getTail(ListNode *head) {
          if (!head) return nullptr;
          while (head->next) {
              head = head->next;
          }
          return head;
      }
  };
  
  ```

## [面试题 02.01. 移除重复节点](https://leetcode.cn/problems/remove-duplicate-node-lcci/)

1. >编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。
   >
   >**示例1:**
   >
   >```
   > 输入：[1, 2, 3, 3, 2, 1]
   > 输出：[1, 2, 3]
   >```

2. ```cpp
   #include <unordered_set>
   
   class Solution {
   public:
       ListNode* removeDuplicates(ListNode* head) {
           if (!head || !head->next) {
               return head;
           }
           
           std::unordered_set<int> seen;
           seen.insert(head->val);
           ListNode* prev = head;
           ListNode* curr = head->next;
           
           while (curr) {
               if (seen.count(curr->val)) {
                   // 如果当前节点值已经存在于哈希集合中，说明是重复节点，删除当前节点
                   prev->next = curr->next;
                   delete curr;
               } else {
                   // 否则，将当前节点值加入哈希集合中，并更新prev指针
                   seen.insert(curr->val);
                   prev = curr;
               }
               curr = prev->next;
           }
           
           return head;
       }
   };
   
   ```

3. 

## [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

1. <img src="../myNotes/h5200/images/image-20240329150450158.png" alt="image-20240329150450158" style="zoom:50%;" />

2. ```cpp
   class Solution {
   private:
       int getLen(ListNode* head) {
           int len = 0;
           ListNode* p = head;
           while (p) {
               len++;
               p = p->next;
           }
           return len;
       }
   public:
       ListNode* middleNode(ListNode* head) {
           if (!head || !head->next) return head;
           int len = getLen(head);
           len /= 2;
           
           ListNode* p = head;
           while (len--) {
               p = p->next;
           }
           return p;
       }
   };
   ```



## [面试题 02.03. 删除中间节点](https://leetcode.cn/problems/delete-middle-node-lcci/)

1. 若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。

   假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。

   例如，传入节点 `c`（位于单向链表 `a->b->c->d->e->f` 中），将其删除后，剩余链表为 `a->b->d->e->f`

2. ```cpp
   class Solution {
   public:
       // 后面一个结点的值替换为前一个，然后删除下一个节点。
       void deleteNode(ListNode* node) {
           if (!node || !node->next) return; // 题上说了不是最后一个结点
   
           ListNode* nextNode = node->next;
           node->val = nextNode->val;
           node->next = nextNode->next;
   
           delete nextNode;
       }
   };
   ```



## [LCR 024. 反转链表](https://leetcode.cn/problems/UHnkqh/)

1. <img src="../myNotes/h5200/images/image-20240329163723038.png" alt="image-20240329163723038" style="zoom:50%;" />

2. ```cpp
   class Solution {
   public:
       ListNode* reverseList(ListNode* head) {
           ListNode* pre = nullptr;
           ListNode* cur = head;
   
           while (cur) {
               ListNode* nextList = cur->next;
               cur->next = pre;
               pre = cur;
               cur = nextList;
           }
           return pre; 
       }
   };
   ```

3. 最后pre不是空的，cur是空的。



## [LCR 142. 训练计划 IV](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

1. >给定两个以 **有序链表** 形式记录的训练计划 `l1`、`l2`，分别记录了两套核心肌群训练项目编号，请合并这两个训练计划，按训练项目编号 **升序** 记录于链表并返回。
   >
   >**注意**：新链表是通过拼接给定的两个链表的所有节点组成的。
   >
   > 
   >
   >**示例 1：**
   >
   >```txt
   >输入：l1 = [1,2,4], l2 = [1,3,4]
   >输出：[1,1,2,3,4,4]
   >```

2. ```cpp
       ListNode* dummy = new ListNode(0);
       ListNode* current = dummy;
   
       while (l1 != nullptr && l2 != nullptr) {
           if (l1->val < l2->val) {
               current->next = l1;
               l1 = l1->next;
           } else {
               current->next = l2;
               l2 = l2->next;
           }
           current = current->next;
       }
   
       current->next = (l1 != nullptr) ? l1 : l2;
   
       return dummy->next;
   ```

## [1171. 从链表中删去总和值为零的连续节点](https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/)

1. 看了一个视频，不太懂啊

2. 懂了，就是一个连续的区间，由于哈希表的一个key只可以对应一个value，所以重复出现的会被删除。出现了，就说明是说。原本的sum值都有（你想一想，都是正数连续的递增的，但是现在由于有负数，导致一些抵消了，value消失了）所以，第二次循环的时候，就直接跳过这一段，直接指向下一段的结点。

3. ![image-20240330101548937](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240330101548937.png)

4. ```cpp
   /**
    * Definition for singly-linked list.
    * struct ListNode {
    *     int val;
    *     ListNode *next;
    *     ListNode() : val(0), next(nullptr) {}
    *     ListNode(int x) : val(x), next(nullptr) {}
    *     ListNode(int x, ListNode *next) : val(x), next(next) {}
    * };
    */
   class Solution {
   public:
       ListNode* removeZeroSumSublists(ListNode* head) {
       // 创建虚拟头节点
       ListNode* dummy = new ListNode(0);
       dummy->next = head;
       
       // 创建哈希表，存储前缀和及对应节点的指针
       std::unordered_map<int, ListNode*> prefixSumMap;
       int sum = 0;
       
       // 计算前缀和并存储到哈希表中
       for (ListNode* p = dummy; p != nullptr; p = p->next) {
           sum += p->val;
           prefixSumMap[sum] = p;
       }
       
       sum = 0;
       // 再次遍历链表，根据前缀和找到对应的节点并删除中间节点
       for (ListNode* p = dummy; p != nullptr; p = p->next) {
           sum += p->val;
           // 也可以写成
           //if (mapp.count(sum))
           if (prefixSumMap.find(sum) != prefixSumMap.end()) {
               // 如果前缀和存在，则将当前节点的 next 指针指向哈希表中对应前缀和的节点的下一个节点
               p->next = prefixSumMap[sum]->next;
           }
       }
       
       return dummy->next;
   }
   
   };
   ```

5. ```cpp
   class Solution {
   public:
       ListNode* removeZeroSumSublists(ListNode* head) {
           ListNode* dummy = new ListNode(0);
           dummy->next = head;
   
           unordered_map<int, ListNode*> mapp;
           int sum = 0;
           ListNode* p = dummy;
           while (p) {
               sum += p->val;
               mapp[sum] = p;
               p = p->next;
           }
           // 还得再遍历一次
           sum = 0;
           p = dummy;
           while (p) {
               sum += p->val;
               if (mapp.count(sum)) {
                   p->next = mapp[sum]->next;
               }
               p = p->next;
           }
           return dummy->next;
       }
   };
   ```

   



##  [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

1. <img src="../myNotes/h5200/images/image-20240330100616004.png" alt="image-20240330100616004" style="zoom:50%;" />

2. ```cpp
   ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
       ListNode* dummy = new ListNode(0); // 创建虚拟头节点
       ListNode* p = dummy;
       int carry = 0; // 进位
   
       /*
       	这样做进位的都走到后面，就是低位向高位进位
       */
       while (l1 || l2) {
           int num1 = l1 ? l1->val : 0; // 获取l1当前节点的值，如果l1为空则取0 ,是为了应对，两个链表长度不一样的情况
           int num2 = l2 ? l2->val : 0; // 获取l2当前节点的值，如果l2为空则取0
   
           int sum = num1 + num2 + carry; // 计算当前位置的和
           carry = sum / 10; // 计算进位
           p->next = new ListNode(sum % 10); // 创建新节点存储和的个位数
           p = p->next; // 移动p指针到下一个节点
   
           if (l1) l1 = l1->next; // 移动l1指针到下一个节点
           if (l2) l2 = l2->next; // 移动l2指针到下一个节点
       }
   
       if (carry > 0) {
           p->next = new ListNode(carry); // 如果还有进位，需要在末尾添加一个额外节点
       }
   
       return dummy->next; // 返回结果链表的头节点
   }
   
   ```



## [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

1. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240330111003233.png" alt="image-20240330111003233" style="zoom:50%;" />

2. 是位置，不是值

3. ```cpp
   class Solution {
   private:
       ListNode* reverse(ListNode* head) {
           ListNode* pre = nullptr;
           ListNode* cur = head;
           while (cur) {
               ListNode* nextList = cur->next;
               cur->next = pre;
               pre = cur;
               cur = nextList;
           }
           return pre;
       }
       ListNode* getTail(ListNode* head) {
           while (head->next) {
               head = head->next;
           }
           return head;
       }
   public:
       ListNode* reverseBetween(ListNode* head, int left, int right) {
           ListNode* dummy = new ListNode(-1);
           dummy->next = head;
           ListNode* pre = dummy;
           // 找到区间的前一个结点
           for (int i = 1; i < left; i++) {
               pre = pre->next;
           }
           ListNode* cur = pre->next; // 要排序的区间第一个节点
   
           ListNode* pre1 = dummy;
           for (int i = 0; i < right; i++) {
               pre1 = pre1->next;
           }
           ListNode* pre2 = pre1->next;
           pre1->next = nullptr;
           
           pre->next = reverse(cur);
           getTail(pre)->next = pre2;
   
           return dummy->next;
       }
   };
   ```

4. gpt给的，没仔细看

   ```cpp
   ListNode* reverseBetween(ListNode* head, int left, int right) {
       if (!head || left == right) {
           return head; // 如果链表为空或left等于right，则直接返回链表头节点
       }
   
       ListNode* dummy = new ListNode(0); // 创建虚拟头节点
       dummy->next = head;
       ListNode* pre = dummy;
   
       // 找到需要反转的区间的前一个节点
       for (int i = 1; i < left; ++i) {
           pre = pre->next;
       }
   
       ListNode* cur = pre->next; // 当前需要反转的节点
       ListNode* next = nullptr;
       
       // 反转区间内的节点
       for (int i = 0; i < right - left; ++i) {
           next = cur->next; // 先保存下一个节点
           cur->next = next->next; // 将当前节点的next指针指向下一个节点的next节点
           next->next = pre->next; // 将下一个节点的next指针指向反转区间的前一个节点
           pre->next = next; // 将反转区间的前一个节点的next指针指向下一个节点
       }
   
       return dummy->next; // 返回反转后的链表头节点
   }
   
   ```

## [37. 删除链表中的节点](https://leetcode.cn/problems/delete-node-in-a-linked-list/)

1. > 有一个单链表的 `head`，我们想删除它其中的一个节点 `node`。
   >
   > 给你一个需要删除的节点 `node` 。你将 **无法访问** 第一个节点 `head`。
   >
   > 链表的所有值都是 **唯一的**，并且保证给定的节点 `node` 不是链表中的最后一个节点。
   >
   > 删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：
   >
   > - 给定节点的值不应该存在于链表中。
   > - 链表中的节点数应该减少 1。
   > - `node` 前面的所有值顺序相同。
   > - `node` 后面的所有值顺序相同。

2. ```cpp
   class Solution {
   public:
       void deleteNode(ListNode* node) {
           // 后一个的值移动到前一个，然后把下一个节点删除
           ListNode* laterNode = node->next;
           node->val = laterNode->val;
           node->next = laterNode->next;
       }
   };
   ```



## [148. 排序链表](https://leetcode.cn/problems/sort-list/)

- 我自己的，写408肯定不行

- ```cpp
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode() : val(0), next(nullptr) {}
   *     ListNode(int x) : val(x), next(nullptr) {}
   *     ListNode(int x, ListNode *next) : val(x), next(next) {}
   * };
   */
  class Solution {
  private:
      int getLen(ListNode* head) {
          int len = 0;
          while (head) {
              len++;
              head = head->next;
          }
          return len;
      }
  public:
      ListNode* sortList(ListNode* head) {
          if (!head || !head->next) return head;
          int len = getLen(head);
          int a[len];
          int index = 0;
          for (ListNode* p = head; p; p = p->next) {
              a[index++] = p->val;
          }
          sort(a, a + len);
          index = 0;
          for (ListNode* p = head; p; p = p->next) {
              p->val = a[index++];
          }
          return head;
      }
  };
  ```

  

1. **进阶：**你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？**问一下gpt** 

2. **归并排序** 是先排序再划分递归，**快速排序** 是先递归再排序

3. ```cpp
   // 定义链表节点结构
   struct ListNode {
       int val;
       ListNode *next;
       ListNode(int x) : val(x), next(nullptr) {}
   };
   
   // 定义归并排序函数
   class Solution {
   public:
       ListNode* sortList(ListNode* head) {
           // 如果链表为空或者只有一个节点，则直接返回
           if (!head || !head->next) return head;
   
           // 定义两个指针，slow指针每次移动一步，fast指针每次移动两步，找到链表的中间节点
           ListNode *slow = head, *fast = head->next;
           while (fast && fast->next) {
               slow = slow->next;
               fast = fast->next->next;
           }
   
           // 将链表从中间断开，left指向前半部分链表的头节点，right指向后半部分链表的头节点
           ListNode* right = slow->next;
           slow->next = nullptr;
   
           // 递归对左右两部分链表进行排序
           ListNode* left_sorted = sortList(head);
           ListNode* right_sorted = sortList(right);
   
           // 合并排序后的左右两部分链表
           return merge(left_sorted, right_sorted);
       }
   
   private:
       // 定义合并两个有序链表的函数
       ListNode* merge(ListNode* l1, ListNode* l2) {
           ListNode* dummy = new ListNode(0); // 创建虚拟头节点
           ListNode* cur = dummy; // 创建当前指针，并指向虚拟头节点
   
           // 循环比较两个链表节点的值，并按升序将它们合并到结果链表中
           // 只要是其中有一个为空就跳出。
           while (l1 && l2) {
               if (l1->val < l2->val) {
                   cur->next = l1;
                   l1 = l1->next;
               } else {
                   cur->next = l2;
                   l2 = l2->next;
               }
               cur = cur->next;
           }
   
           // 将剩余的节点接到结果链表中
           cur->next = l1 ? l1 : l2;
   
           return dummy->next; // 返回合并后的链表头节点
       }
   };
   
   ```



## [1669. 合并两个链表](https://leetcode.cn/problems/merge-in-between-linked-lists/)

1. ![image-20240330113925273](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240330113925273.png)

2. ```cpp
   class Solution {
   private:
       ListNode* getNodeByIndex(ListNode* head, int index) {
           // 传进来的是头结点
           for (int i = 0; i < index; i++) {
               head = head->next;
           }
           return head;
       }
       ListNode* getTail(ListNode* head) {
           while (head->next) {
               head = head->next;
           }
           return head;
       }
   public:
       ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {
           ListNode* pre = getNodeByIndex(list1, a - 1);
           ListNode* after = getNodeByIndex(list1, b + 1);
           // 断开
           pre->next = nullptr;
           pre->next = list2;
   
           //连接新的
           getTail(list2)->next = after;
           return list1;
       }
   };
   ```



## [2181. 合并零之间的节点](https://leetcode.cn/problems/merge-nodes-in-between-zeros/)

1. ![image-20240330115449732](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240330115449732.png)

2. ```cpp
   class Solution {
   public:
       ListNode* mergeNodes(ListNode* head) {
           ListNode* dummy = new ListNode(0); // 创建虚拟头节点
           ListNode* prev = dummy; // 指针 prev 指向虚拟头节点
           int sum = 0; // 记录累加的值
   
           // 遍历链表
           while (head) { // 得吧所有节点走完，所以是cur不是cur->next
               // 如果当前节点的值为 0
               if (head->val != 0) {
                   sum += head->val; // 将当前节点的值累加到 sum 中
               } else {
                   // 如果当前节点的值不为 0，且 sum 不为 0
                   if (sum != 0) {
                       prev->next = new ListNode(sum); // 将累加的值作为新节点的值
                       prev = prev->next; // 移动 prev 指针到新节点
                       sum = 0; // 将 sum 重置为 0
                   }
               }
               head = head->next; // 移动 head 指针到下一个节点
           }
   
           return dummy->next; // 返回虚拟头节点的下一个节点作为合并后的链表头节点
       }
   };
   ```



## [86. 分隔链表](https://leetcode.cn/problems/partition-list/)

1. <img src="../myNotes/h5200/images/image-20240330131751111.png" alt="image-20240330131751111" style="zoom:50%;" />

2. ```cpp
   class Solution {
   public:
       ListNode* partition(ListNode* head, int x) {
           if (!head || !head->next) return head;
           // 首先创建两个链表，再创建两个指针
           ListNode* lowList = new ListNode(-1);
           ListNode* highList = new ListNode(-1);
   
           ListNode* pre = lowList;
           ListNode* later = highList;
   
           // 结果,其实不用创建，直接最后两个连接就可以了
           ListNode* dummy = new ListNode(-1);
           while (head) {
               if (head->val < x) {
                   pre->next = new ListNode(head->val);
                   pre = pre->next;
               } else {
                   later->next = new ListNode(head->val);
                   later = later->next;
               }
               head = head->next;
           }
           pre->next = highList->next;
           return lowList->next;
       }
   };
   ```



## [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

1. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240330135011701.png" alt="image-20240330135011701" style="zoom:50%;" />

2. ```cpp
   class Solution {
   private:
       // 用笨的方法，我先求出来先序序列
       vector<TreeNode*> vec;
       void traversal(TreeNode* root) {
           if (!root) return;
           vec.push_back(root);
           traversal(root->left);
           traversal(root->right);
       }
   public:
       void flatten(TreeNode* root) {
           if (!root) return;
           traversal(root);
           
           TreeNode* pre = nullptr;
           for (TreeNode* node : vec) {
               if (pre) {
                   pre->left = nullptr;
                   pre->right = node;
               }
               pre = node;
           }
       }
   };
   ```



## [622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/)

1. ```cpp
   class MyCircularQueue {
   private:
       vector<int> data;
       int head;
       int tail;
       int size;
   public:
       MyCircularQueue(int k) {
           data.resize(k);
           head = -1;
           tail = -1;
           size = k;
       }
       
       bool enQueue(int value) {
           if (isFull()) return false;
           if (isEmpty()) head = 0;
           tail = (tail + 1) % size;
           data[tail] = value;
           return true;
       }
       
       bool deQueue() {
           if (isEmpty()) return false;
           //如果是最后一个元素特殊处理
           if (head == tail) {
               head = -1;
               tail = -1;
               return true;
           }
           head = (head + 1) % size;
           return true;
       }
       
       int Front() {
           if (isEmpty()) return -1;
           return data[head];
       }
       
       int Rear() {
           if (isEmpty()) return -1;
           return data[tail];
       }
       
       bool isEmpty() {
           if (head == -1) return true;
           return false;
       }
       
       bool isFull() {
           if ((tail + 1) % size == head) return true;
           return false;
       }
   };
   ```



## [641. 设计循环双端队列](https://leetcode.cn/problems/design-circular-deque/)

1. `rear`实际上指的是，最后一个元素的下一个位置，

2. 实际上容量 == `size + 1` 是为了区分，空和满

3. ```cpp
   class MyCircularDeque {
   private:
       vector<int> data;
       int front;
       int rear;
       int capacity;
   public:
       // k是用户实际上希望存储的元素的数量
       MyCircularDeque(int k) {
           data.resize(k + 1);
           front = 0;
           rear = 0;
           capacity = k + 1;
       }
       
       bool insertFront(int value) {
           if (isFull()) return false;
           front = (front - 1 + capacity) % capacity;
           data[front] = value;
           return true;
       }
       
       bool insertLast(int value) {
           if (isFull()) return false;
           data[rear] = value;
           rear = (rear + 1) % capacity;
           return true;
       }
       
       bool deleteFront() {
           if (isEmpty()) return false;
           front = (front + 1) % capacity;
           return true;
       }
       
       bool deleteLast() {
           if (isEmpty()) return false;
           rear = (rear - 1 + capacity) % capacity;
           return true;
       }
       
       int getFront() {
           if (isEmpty()) return -1;
           return data[front];
       }
       
       int getRear() {
           if (isEmpty()) return -1;
           return data[(rear - 1 + capacity) % capacity];
       }
       
       bool isEmpty() {
           return front == rear;
       }
       
       bool isFull() {
           return (rear + 1) % capacity == front;
       }
   };
   ```

## [147. 对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/)

1. 

## [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

1. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240331113316207.png" alt="image-20240331113316207" style="zoom:50%;" />

2. ```cpp
   class Solution {
   public:
       Node* connect(Node* root) {
           vector<vector<Node*>> res;
           if (!root) return NULL;
           queue<Node*> que;
           que.push(root);
   
           while (!que.empty()) {
               int size = que.size();
               vector<Node*> vec;
               for (int i = 0; i < size; i++) {
                   Node* node = que.front();
                   que.pop();
                   vec.push_back(node);
                   if (node->left) que.push(node->left);
                   if (node->right) que.push(node->right);
               }
               res.push_back(vec);
           }
           
           for (auto& it : res) {
               for (size_t i = 0; i < it.size(); i++) {
                   it[i]->next = (i < it.size() - 1) ? it[i + 1] : nullptr;
               }
           }
           
           return root;
       }
   };
   ```

3. > 
   > 在循环中，您使用了迭代器 `x` 来遍历 `it` 中的节点。在内部，您尝试使用 `x` 的下一个元素 `*(x + 1)` 来设置当前节点的 `next` 指针。但是，这种方法会导致问题，因为 `x + 1` 并不是有效的迭代器。
   >
   > 正确的做法是，使用 `it` 中的索引来访问节点，并确保索引在合法范围内。以下是修改后的代码：
   >
   > ```cpp
   >   for (auto& it : res) {
   >             Node* lastNode = nullptr;
   >             for (auto x = it.begin(); x != it.end(); x++) {
   >                 (*x)->next = *(x + 1);
   >                 if (x->next == nullptr) lastNode = x;
   >             }
   >             //(it.end())->next = NULL;
   >             lastNode->next = NULL;
   >         }
   > ```
   >
   > 这样不行！

---

## [143. 重排链表](https://leetcode.cn/problems/reorder-list/)

1. 给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

   ```
   L0 → L1 → … → Ln - 1 → Ln
   ```

   请将其重新排列后变为：

   ```
   L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
   ```

   不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

2. ```cpp
   class Solution {
   public:
       void reorderList(ListNode* head) {
           if (!head || !head->next) return; // 链表为空或只有一个节点时，无需重排
   
           // 使用快慢指针找到链表的中间节点
           ListNode *slow = head, *fast = head;
           while (fast->next && fast->next->next) {
               slow = slow->next;
               fast = fast->next->next;
           }
   
           // 将链表从中间节点处分为两个子链表
           ListNode *secondHead = slow->next;
           slow->next = nullptr;
   
           // 反转第二个子链表
           secondHead = reverseList(secondHead);
   
           // 将两个子链表合并
           mergeLists(head, secondHead);
       }
   
   private:
       // 反转链表
       ListNode* reverseList(ListNode* head) {
           ListNode *prev = nullptr, *curr = head;
           while (curr) {
               ListNode* nextNode = curr->next;
               curr->next = prev;
               prev = curr;
               curr = nextNode;
           }
           return prev;
       }
   
       // 合并两个链表,交替合并
       void mergeLists(ListNode* l1, ListNode* l2) {
           while (l1 && l2) {
               ListNode* l1Next = l1->next;
               ListNode* l2Next = l2->next;
   
               l1->next = l2;
               l2->next = l1Next;
   
               l1 = l1Next;
               l2 = l2Next;
           }
       }
   };
   ```




## [面试题 02.08. 环路检测](https://leetcode.cn/problems/linked-list-cycle-lcci/)

1. 我的有问题的代码

2. ```cpp
   class Solution {
   public:
       ListNode *detectCycle(ListNode *head) {
           // 反正我知道做法，但是证明忘了
           if (!head || !head->next) return NULL;
   
           ListNode* low = head;
           ListNode* fast = head;
           
           while (low != fast) {
               low = low->next;
               fast = fast->next->next;
           }
           // 相遇了，让慢的回到起点
           low = head;
           while (low != fast) {
               low = low->next;
               fast = fast->next;
           }
           return low;
       }   
   };
   ```

3. > 但是，你的算法中存在一个问题：在检测到快慢指针相遇时，并没有判断快指针 `fast` 是否已经到达链表末尾（即 `fast` 的下一个节点是否为空）。如果链表中没有环，那么快指针最终会到达链表的末尾，此时应该返回 `NULL`，表示链表中不存在环。

4. ```cpp
   class Solution {
   public:
       ListNode *detectCycle(ListNode *head) {
           // 反正我知道做法，但是证明忘了
           if (!head || !head->next) return NULL;
   
           ListNode* slow = head;
           ListNode* fast = head;
           
           while (fast && fast->next) {
               slow = slow->next;
               fast = fast->next->next;
               // 判断快指针是否已经到达链表末尾
               if (slow == fast) {
                   // 相遇了，让慢的回到起点
                   slow = head;
                   while (slow != fast) {
                       slow = slow->next;
                       fast = fast->next;
                   }
                   return slow; // 返回环的入口节点
               }
           }
           return NULL; // 链表中不存在环
       }   
   };
   
   ```

## [2807. 在链表中插入最大公约数](https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/)

1. ![image-20240401092918361](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401092918361.png)

2. ```cpp
   class Solution {
   private:
       int gcd(int a, int b) {
           if (a % b == 0) return b;
           return gcd(b, a % b);
       }
   public:
       ListNode* insertGreatestCommonDivisors(ListNode* head) {
           if (!head || !head->next) return head;
           ListNode* pre = head;
           ListNode* cur = head->next;
   
           while (cur) { // 得把所有节点走完，不是cur->next
               ListNode* newNode = new ListNode(gcd(pre->val, cur->val));
               newNode->next = cur;
               pre->next = newNode;
               pre = cur;
               cur = cur->next;
           }
           return head;
       }
   };
   ```



## [2816. 翻倍以链表形式表示的数字](https://leetcode.cn/problems/double-a-number-represented-as-a-linked-list/)

0. ![image-20240401094203692](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401094203692.png) 

1. ```cpp
   class Solution {
   public:
       ListNode* doubleIt(ListNode* head) {
           if (!head) return head;
           // stack
           stack<int> st;
           ListNode* p = head;
           while (p) {
               st.push(p->val);
               p = p->next;
           }
           // 构造一个新的链表
           // 再创造当前节点的时候，还需要保存进位
           int carry = 0;
           ListNode* dummy = new ListNode(-1);
           ListNode* later = nullptr;
           while (!st.empty()) {
               int sum = carry;
               sum += st.top() * 2 % 10;
               carry = st.top() * 2 / 10;
               st.pop();
               dummy->next = new ListNode(sum);
               dummy->next->next = later;
               later = dummy->next;
           }
           if (carry > 0) {
               dummy->next = new ListNode(carry);
               dummy->next->next = later;
           }
           return dummy->next;
       }
   };
   ```



## [725. 分隔链表](https://leetcode.cn/problems/split-linked-list-in-parts/)

1. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401103508220.png" alt="image-20240401103508220" style="zoom:50%;" />

2. ```cpp
   #include <vector>
   #include <cmath> // 包含 ceil() 函数
   using namespace std;
   
   struct ListNode {
       int val;
       ListNode *next;
       ListNode(int x) : val(x), next(NULL) {}
   };
   
   class Solution {
   public:
       vector<ListNode*> splitListToParts(ListNode* head, int k) {
           // 计算链表长度
           int len = 0;
           ListNode* curr = head;
           while (curr) {
               len++;
               curr = curr->next;
           }
           
           // 计算每部分的平均长度和余数
           int avg = len / k;
           int extra = len % k;
           
           vector<ListNode*> result;
           curr = head;
           for (int i = 0; i < k; i++) {
               // 计算当前部分的长度
               int part_len = avg + (i < extra ? 1 : 0);
               if (part_len == 0) {
                   result.push_back(nullptr);
                   continue;
               }
               
               // 将当前部分的头结点添加到结果中
               result.push_back(curr);
               
               // 移动指针到当前部分的末尾
               for (int j = 1; j < part_len; j++) {
                   curr = curr->next;
               }
               
               // 断开当前部分与后面部分的连接
               ListNode* temp = curr->next;
               curr->next = nullptr;
               curr = temp;
           }
           
           return result;
       }
   };
   
   ```

3. ```cpp
   class Solution {
   private:
       int getLen(ListNode* head) {
           int len = 0;
           while (head) {
               len++;
               head = head->next;
           }
           return len;
       }
   public:
       vector<ListNode*> splitListToParts(ListNode* head, int k) {
           int len = getLen(head);
           int basis = len / k; // 基础长度
           int m = len % k; // m个basis + 1个
           vector<ListNode*> res;
           ListNode* dummy = new ListNode(-1);
           dummy->next = head;
           // m == 0特殊处理
           if (m == 0) {
               while (k--) {
                   if (head) {
                       res.push_back(head);
                       head = head->next;
                   } else {
                       res.push_back(nullptr);
                   }
               }
               return res;
           }
           while (m--) {
               ListNode* cur = dummy;
               for (int i = 0; i < basis + 1; i++) {
                   cur = cur->next;
               }
               ListNode* nextList = cur->next;
               cur->next = nullptr;
               res.push_back(dummy->next);
               dummy->next = nextList;
           }
           ListNode* cur = dummy;
           while (cur->next && cur) {
               for (int i = 0; i < basis; i++) {
                   cur = cur->next;
               }
               ListNode* nextList = cur->next;
               cur->next = nullptr;
               res.push_back(dummy->next);
               dummy->next = nextList;
           }
           return res;
       }
   }; //修改我的程序的bug给出修改意见，并返回最终程序。
   ```

4. 

## [1019. 链表中的下一个更大节点](https://leetcode.cn/problems/next-greater-node-in-linked-list/)

1. ![image-20240401111106010](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401111106010.png) 

2. ```cpp
   class Solution {
   private:
       ListNode* reverseList(ListNode* head) {
           ListNode* pre = nullptr;
           ListNode* cur = head;
           while (cur) {
               ListNode* nextNode = cur->next;
               cur->next = pre;
               pre = cur;
               cur = nextNode;
           }
           return pre;
       }
   public:
       vector<int> nextLargerNodes(ListNode* head) {
           if (!head) return vector<int>();
   
           // 反转链表
           ListNode* reversedHead = reverseList(head);
           vector<int> result;
           stack<int> stk;
   
           // 遍历反转后的链表
           while (reversedHead) {
               int val = reversedHead->val;
   
               // 将比当前节点值小的节点值从栈中弹出
               while (!stk.empty() && stk.top() <= val) {
                   stk.pop();
               }
   
               // 如果栈为空，说明当前节点是最大值，下一个更大节点值为0
               if (stk.empty()) {
                   result.push_back(0);
               } else { // 否则，下一个更大节点值为栈顶元素
                   result.push_back(stk.top());
               }
   
               // 将当前节点值压入栈中
               stk.push(val);
               // 移动到下一个节点
               reversedHead = reversedHead->next;
           }
   
           // 将结果反转得到最终答案
           reverse(result.begin(), result.end());
   
           return result;
       }
   };
   
   ```



## [2487. 从链表中移除节点](https://leetcode.cn/problems/remove-nodes-from-linked-list/)

1. ![image-20240402123402414](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240402123402414.png)

2. ![image-20240402123439614](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240402123439614.png) 

3. ```cpp
   class Solution {
   public:
       ListNode* reverseList(ListNode* head) {
           ListNode* prev = nullptr;
           ListNode* curr = head;
           while (curr) {
               ListNode* nextNode = curr->next;
               curr->next = prev;
               prev = curr;
               curr = nextNode;
           }
           return prev;
       }
       
       ListNode* removeRightGreaterNodes(ListNode* head) {
           if (!head || !head->next) return head;
           
           head = reverseList(head); // 反转链表以便从左到右比较
           
           ListNode* dummy = new ListNode(0);
           dummy->next = head;
           
           ListNode* curr = head;
           ListNode* prev = dummy;
           
           int maxVal = curr->val; // 记录当前最大值
           
           while (curr) {
               if (curr->val < maxVal) {
                   // 移除当前节点
                   prev->next = curr->next;
                   ListNode* temp = curr;
                   curr = curr->next;
                   delete temp;
               } else {
                   // 更新最大值并移动指针
                   maxVal = curr->val;
                   prev = curr;
                   curr = curr->next;
               }
           }
           
           ListNode* result = reverseList(dummy->next); // 恢复链表原始顺序
           delete dummy;
           
           return result;
       }
   };
   
   ```



## [LCR 154. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

1. ```cpp
   class Solution {
   public:
       Node* copyRandomList(Node* head) {
           unordered_map<Node*, Node*> map;
           Node* t = head;
           Node* dummy = new Node(-10010);
           Node* cur = dummy;
   
           // 第一遍遍历：复制节点并将原节点与复制节点的映射关系存储到哈希表中
           while (head != nullptr) {
               Node* node = new Node(head->val);
               map[head] = node;
               cur->next = node;
               cur = cur->next;
               head = head->next;
           }
   
           // 第二遍遍历：复制 random 指针
           cur = dummy->next;
           head = t;
           while (head != nullptr) {
               cur->random = map[head->random]; // 不是map[head]->random
               cur = cur->next;
               head = head->next;
           }
   
           return dummy->next;
       }
   };
   
   ```



## [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

- > 问：需要几个哨兵节点？
  >
  > 答：一个就够了。一开始哨兵节点 dummy\textit{dummy}dummy 的 prev\textit{prev}prev 和 next\textit{next}next 都指向 dummy\textit{dummy}dummy。随着节点的插入，dummy\textit{dummy}dummy 的 next\textit{next}next 指向链表的第一个节点（最上面的书），prev\textit{prev}prev 指向链表的最后一个节点（最下面的书）。
  >
  > 问：为什么节点要把 key\textit{key}key 也存下来？
  >
  > 答：在删除链表末尾节点时，也要删除哈希表中的记录，这需要知道末尾节点的 key\textit{key}key。
  >

1. ```cpp
   class Node {
   public:
       int key, value;
       Node *prev, *next;
   
       Node(int k = 0, int v = 0) : key(k), value(v) {}
   };
   
   class LRUCache {
   private:
       int capacity;
       Node *dummy; // 哨兵节点
       unordered_map<int, Node*> key_to_node;
   
       // 删除一个节点（抽出一本书）
       void remove(Node *x) {
           x->prev->next = x->next;
           x->next->prev = x->prev;
       }
   
       // 在链表头添加一个节点（把一本书放在最上面）
       void push_front(Node *x) {
           x->prev = dummy;
           x->next = dummy->next;
           x->prev->next = x;
           x->next->prev = x;
       }
   
       Node *get_node(int key) {
           auto it = key_to_node.find(key);
           if (it == key_to_node.end()) // 没有这本书
               return nullptr;
           auto node = it->second; // 有这本书
           remove(node); // 把这本书抽出来
           push_front(node); // 放在最上面
           return node;
       }
   
   public:
       LRUCache(int capacity) : capacity(capacity), dummy(new Node()) {
           dummy->prev = dummy;	
           dummy->next = dummy;
       }
   
       int get(int key) {
           auto node = get_node(key);
           return node ? node->value : -1;
       }
   
       void put(int key, int value) {
           auto node = get_node(key);
           if (node) { // 有这本书
               node->value = value; // 更新 value
               return;
           }
           key_to_node[key] = node = new Node(key, value); // 新书
           push_front(node); // 放在最上面
           if (key_to_node.size() > capacity) { // 书太多了
               auto back_node = dummy->prev;
               key_to_node.erase(back_node->key);
               remove(back_node); // 去掉最后一本书
               delete back_node; // 释放内存
           }
       }
   };
   ```



## [61. 旋转链表](https://leetcode.cn/problems/rotate-list/)

1. ![image-20240402145101214](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240402145101214.png)

2. ```cpp
   class Solution {
   private:
       int getLen(ListNode* head) {
           ListNode* cur = head;
           int len = 0;
           while (cur) {
               len++;
               cur = cur->next;
           }
           return len;
       }
       ListNode* getTail(ListNode* head) {
           while (head->next) {
               head = head->next;
           }
           return head;
       }
   public:
       ListNode* rotateRight(ListNode* head, int k) {
           if (!head || !head->next) return head;
           int len = getLen(head);
           if (k % len == 0) return head;
   
           k = k % len;
           ListNode* dummy = new ListNode(-1);
           // 找到前一个节点
           ListNode* pre = head;
           for (int i = 0; i < len - k - 1; i++) {
               pre = pre->next;
           }
           ListNode* cur = pre->next;
           pre->next = nullptr;
           dummy->next = cur;
           getTail(dummy)->next = head;
           return dummy->next;
       }
   };
   ```

3. ![image-20240402145125827](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240402145125827.png) 



## [2058. 找出临界点之间的最小和最大距离](https://leetcode.cn/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/)

1. ```cpp
   class Solution {
   public:
       vector<int> nodesBetweenCriticalPoints(ListNode* head) {
           vector<int> vec;
           ListNode* cur = head;
           while (cur) {
               vec.push_back(cur->val);
               cur = cur->next;
           }
           int len = vec.size();
           vector<int> bucket;
           for (int i = 1; i < len - 1; i++) {
               if (vec[i] > vec[i-1] && vec[i] > vec[i+1]) {
                   bucket.push_back(i);
               }
               if (vec[i] < vec[i-1] && vec[i] < vec[i+1]) {
                   bucket.push_back(i);
               }
           }
           if (bucket.size() < 2) {
               return {-1, -1};
           }
           sort(bucket.begin(), bucket.end());
           int minnD = INT_MAX, maxD = bucket.back() - bucket.front();
               // 不是*(bucket.end()) - *(bucket.begin());
           for (int i = 1; i < bucket.size(); i++) {
               minnD = min(minnD, bucket[i] - bucket[i - 1]);
           }
           return {minnD, maxD};
       }
   };
   ```





## [1367. 二叉树中的链表](https://leetcode.cn/problems/linked-list-in-binary-tree/)

1. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240402152732493.png" alt="image-20240402152732493" style="zoom:50%;" />

2. ```cpp
   // 我的错误代码
   class Solution {
   private:
       bool tag = false;
       // 在中序遍历的过程中，如果发现了节点
       bool dfs(ListNode* head, TreeNode* root) {
           if (head->val != root->val) {
               return false;
           }
           if (!head->next && !root->left && !root->right) {
               return true;
           }
           dfs(head->next, root->left);
           dfs(head->next, root->right);
           return false;
       }
       void traversal(ListNode* head, TreeNode* root) {
           if (!root) return;
           traversal(head, root->left);
           if (head->val == root->val) {
               if (dfs(head, root)) tag = true;
           }
           traversal(head, root->right);
       }
   public:
       bool isSubPath(ListNode* head, TreeNode* root) {
           if (!head) return false;
           traversal(head, root);
           return true;
       }
   };
   ```

3. ```cpp
   class Solution {
   private:
       bool tag = false;
   
       bool dfs(ListNode* head, TreeNode* root) {
           if (!head) return true; // 链表已经遍历完成
           if (!root) return false; // 二叉树遍历结束但链表尚未匹配完成
           if (head->val != root->val) return false; // 当前节点值不匹配
           // 递归遍历左右子树，只要有一个子树满足条件即可
           return dfs(head->next, root->left) || dfs(head->next, root->right);
       }
   
       void traversal(ListNode* head, TreeNode* root) {
           if (!root || tag) return; // 如果 tag 为 true 或者二叉树已经遍历完毕，直接返回
           traversal(head, root->left);
           // 检查当前节点是否与链表头节点匹配，如果匹配，则调用 dfs 函数
           if (head->val == root->val && dfs(head, root)) tag = true;
           traversal(head, root->right);
       }
   
   public:
       bool isSubPath(ListNode* head, TreeNode* root) {
           if (!head || !root) return false; // 空链表或空二叉树
           traversal(head, root);
           return tag;
       }
   };
   
   ```



## [2074. 反转偶数长度组的节点](https://leetcode.cn/problems/reverse-nodes-in-even-length-groups/)

- ![image-20240404101253871](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240404101253871.png)  

- ```cpp
  #include <vector>
  
  struct ListNode {
      int val;
      ListNode *next;
      ListNode(int x) : val(x), next(nullptr) {}
  };
  
  class Solution {
  public:
      ListNode* reverseEvenLengthGroups(ListNode* head) {
          std::vector<ListNode*> nodes; // 用于存储链表节点的指针
          int size = 1; // 初始分组大小为1
  
          // 遍历链表
          for (ListNode* node = head; node != nullptr; node = node->next) {
              nodes.push_back(node); // 将当前节点加入节点数组中
              // 如果已经统计到 size 个节点，或者到达链表末尾
              if (nodes.size() == size || node->next == nullptr) {
                  // 如果当前分组节点数为偶数
                  if (int n = nodes.size(); n % 2 == 0) {
                      // 对于当前分组中的前半部分节点，与后半部分节点进行值交换
                      for (int i = 0; i < n / 2; ++i) {
                          std::swap(nodes[i]->val, nodes[n - 1 - i]->val);
                      }
                  }
                  // 清空节点数组，准备统计下一个分组
                  nodes.clear();
                  size++; // 分组大小加一
              }
          }
  
          return head; // 返回头节点
      }
  };
  
  ```

  

# 二叉树



## 前序遍历

1. ```cpp
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     TreeNode *left;
    *     TreeNode *right;
    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
    * };
    */
   class Solution {
   public:
       void preorder(TreeNode* root, vector<int> & res) {
           if (root == nullptr) {
               return;
           }
           res.push_back(root->val);
           preorder(root->left, res);
           preorder(root->right, res);
       }
   
       vector<int> preorderTraversal(TreeNode* root) {
           vector<int> res;
           preorder(root, res);
           return res;
       }
   };
   ```



## [328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/)

1. ![image-20240331102115838](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240331102115838.png)

2. 积极诶错题意了，连接最后一个奇数结点和第一个偶数节点

3. ```cpp
   class Solution {
   public:
       ListNode* oddEvenList(ListNode* head) {
           // 分开的时候是运用的下标
           if (!head || !head->next) return head;
           // 看一下第一个为啥
           int tag = 0;
           if (head->val % 2 == 1) tag = 1;
   
           ListNode* odd = new ListNode(-1);
           ListNode* even = new ListNode(-1);
   
           // 分别针对两个
           ListNode* oddPtr = odd;
           ListNode* evenPtr = even;
   
           ListNode* cur = head;
           int index = 1;
           while (cur) {
               if (index % 2 == 1) {
                   oddPtr->next = new ListNode(cur->val);
                   oddPtr = oddPtr->next;
               } else {
                   evenPtr->next = new ListNode(cur->val);
                   evenPtr = evenPtr->next;
               }
               cur = cur->next;
               index++;
           }
           //if (tag == 1) {
               oddPtr->next = even->next;
               return odd->next;
           // } else {
           //     evenPtr->next = odd->next;
           //     return even->next;
           // }
       }
   };
   ```

   

## [445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)

1. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240331095650828.png" alt="image-20240331095650828" style="zoom:50%;" /> 

2. ```cpp
   class Solution {
   public:
       ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
           stack<int> s1, s2; // 用栈来存储两个链表的节点值
           while (l1) {
               s1.push(l1->val);
               l1 = l1->next;
           }
           while (l2) {
               s2.push(l2->val);
               l2 = l2->next;
           }
   
           ListNode* head = nullptr; // 结果链表的头指针
           int carry = 0; // 进位
           while (!s1.empty() || !s2.empty() || carry != 0) {
               int sum = carry;
               if (!s1.empty()) {
                   sum += s1.top();
                   s1.pop();
               }
               if (!s2.empty()) {
                   sum += s2.top();
                   s2.pop();
               }
               carry = sum / 10; // 计算进位
               sum %= 10; // 计算当前位的值
   
               ListNode* newNode = new ListNode(sum);
               newNode->next = head;
               head = newNode; // 在头部插入新节点
           }
   
           return head;
       }
   };
   
   ```

3. 

## 后续遍历

1. ```cpp
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     TreeNode *left;
    *     TreeNode *right;
    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
    * };
    */
   class Solution {
   public:
       void postorder(TreeNode* root, vector<int> &res) {
           if (root == nullptr) return;
           postorder(root->left, res);
           postorder(root->right, res);
           res.push_back(root->val);
       }
       vector<int> postorderTraversal(TreeNode* root) {
           vector<int> res;
           postorder(root, res);
           return res;
       }
   };
   ```



## [100. 相同的树](https://leetcode.cn/problems/same-tree/)

0. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240317103035653.png" alt="image-20240317103035653" style="zoom:50%;" /> 

1. ```cpp
   bool isSameTree(TreeNode* p, TreeNode* q) {
       // 如果两个节点都为空，则相同
       if (!p && !q)
           return true;
       // 如果其中一个节点为空，另一个节点非空，则不相同
       if (!p || !q)
           return false;
       // 如果节点的值不相同，则不相同
       if (p->val != q->val)
           return false;
       // 递归检验左右子树
       return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
   }
   ```

   

## [二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

1. 非递归版本的**不好理解** ，中午了有点想瞌睡了，看一下递归的拉倒。

   ```cpp
   class Solution {
   public:
       vector<vector<int>> levelOrder(TreeNode* root) {
           queue<TreeNode*> que;
           if (root != NULL) que.push(root);
           vector<vector<int>> result;
           
           while (!que.empty()) {
               int size = que.size();
               vector<int> vec;
               // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
               for (int i = 0; i < size; i++) {
                   TreeNode* node = que.front();
                   que.pop();
                   vec.push_back(node->val);
                   if (node->left) que.push(node->left);
                   if (node->right) que.push(node->right);
               }
               result.push_back(vec);
           }
           return result;
       }
   };
   ```



### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

1. ![image-20240314145536199](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240314145536199.png) 

2. ```cpp
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     TreeNode *left;
    *     TreeNode *right;
    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
    * };
    */
   class Solution {
   public:
       vector<int> rightSideView(TreeNode* root) {
           vector<int> res;
           queue<TreeNode*> que;
   
           if (root != nullptr) que.push(root);
           while (!que.empty()) {
               int size = que.size();
               for (int i = 0; i < size; i++) {
                   TreeNode* node = que.front();
                   que.pop();
                   if (i == size - 1) res.push_back(node->val); // 每一层的最后元素放入res
                   if (node->left) que.push(node->left);
                   if (node->right) que.push(node->right);
               }
           }
           return res;
       }
   };
   ```



### [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

1. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240314150811396.png" alt="image-20240314150811396" style="zoom: 50%;" /> 

2. ```cpp
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     TreeNode *left;
    *     TreeNode *right;
    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
    * };
    */
   class Solution {
   public:
       vector<double> averageOfLevels(TreeNode* root) {
           queue<TreeNode*> que;
           if (root != nullptr) que.push(root);
           vector<double> res;
   
           while (!que.empty()) {
               int size = que.size();
               double sum = 0;
               for (int i = 0; i < size; i++) {
                   TreeNode* node = que.front();
                   que.pop();
                   sum += node->val;
                   
                   if (node->left) que.push(node->left);
                   if (node->right) que.push(node->right);
               }
               res.push_back(sum / size);
           }
           return res;
       }
   };
   ```



### [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

1. ![image-20240314152305641](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240314152305641.png) 

2. ```cpp
   /*
   // Definition for a Node.
   class Node {
   public:
       int val;
       vector<Node*> children;
   
       Node() {}
   
       Node(int _val) {
           val = _val;
       }
   
       Node(int _val, vector<Node*> _children) {
           val = _val;
           children = _children;
       }
   };
   */
   
   class Solution {
   public:
       vector<vector<int>> levelOrder(Node* root) {
           vector<vector<int>> res;
           queue<Node*> que;
           if (root != NULL) que.push(root);
   
           while (!que.empty()) {
               int size = que.size();
               vector<int> vec;
   
               for (int i = 0; i < size; i++) {
                   Node* node = que.front();
                   que.pop();
                   vec.push_back(node->val);
                   for (int i = 0 ; i < node->children.size(); i++) {
                       if (node->children[i] != NULL) {
                           que.push(node->children[i]);
                       }
                   }
               }
               res.push_back(vec);
           }
           return res;
       }
   };
   ```



## [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

0. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240317092036652.png" alt="image-20240317092036652" style="zoom:50%;" /> 

1. ```cpp
   class Solution {
   public:
       vector<int> res;
       // 我先获取 层序遍历的结果，就是数组套数组，然后对于每一个数组，求最大值，时间复杂度就是O（n*n）
       vector<int> largestValues(TreeNode* root) {
           queue<TreeNode*> que;
           if (root != NULL) que.push(root);
   
           while (!que.empty()) {
               int size = que.size();
               vector<int> vec;
               int maxx = INT_MIN;
   
               for (int i = 0 ; i < size; i++) {
                   
                   TreeNode* node = que.front();
                   que.pop();
                   maxx = node->val > maxx ? node->val : maxx;
                   // vec.push_back(node->val);
                   if (node->left) que.push(node->left);
                   if (node->right) que.push(node->right);
               }
               // 现在是一个vec好了，找一下最大值。
               res.push_back(maxx);
           }
           return res;
       }
   };
   ```

2. 



### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

1. 就是有几层就可以了。

2. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240314154102307.png" alt="image-20240314154102307" style="zoom:50%;" />

3. ```cpp
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     TreeNode *left;
    *     TreeNode *right;
    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
    * };
    */
   class Solution {
   public:
       int maxDepth(TreeNode* root) {
           queue<TreeNode*> que;
           vector<vector<int>> res;
           if (root != nullptr) que.push(root);
   
           while (!que.empty()) {
               int size = que.size();
               vector<int> vec;
   
               for (int i = 0; i < size; i++) {
                   TreeNode* node = que.front();
                   que.pop();
                   vec.push_back(node->val);
                   if (node->left) que.push(node->left);
                   if (node->right) que.push(node->right);
               }
               res.push_back(vec);
           }
           return res.size();
       }
   };
   ```

2. 也可以用**添加一个参数的思想** 

3. ```cpp
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     TreeNode *left;
    *     TreeNode *right;
    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
    * };
    */
   class Solution {
   public:
       int result;
       int findMaxdeep(TreeNode* root, int deep) {
           result = deep > result ? deep : result; // 更新result
           if (root->left == nullptr && root ->right == nullptr) return result; // 是一个叶子结点。
   
           if (root-> left != nullptr) {
               deep++;
               findMaxdeep(root->left, deep);
               deep--;
           }
           if (root->right != nullptr) {
               deep++;
               findMaxdeep(root->right, deep);
               deep--;
           }
           return result;
       }
   
       int maxDepth(TreeNode* root) {
           result = 0;
           if (root == nullptr) return result;
           return findMaxdeep(root, 1);
       }
   };
   ```

   

### [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

0. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240317091802857.png" alt="image-20240317091802857" style="zoom: 50%;" /> 

1. gpt给出的使用递归法，真简单啊！

2. 首先判断是空节点，还是叶子结点。

   1. ```cpp
      class Solution {
      public:
          int minDepth(TreeNode* root) {
              // 如果树为空，返回深度为0
              if (!root)
                  return 0;
              // 如果根节点的左右子树都为空，说明是叶子节点，返回深度为1
              if (!root->left && !root->right)
                  return 1;
              // 如果左子树为空，说明只需考虑右子树的深度
              if (!root->left)
                  return 1 + minDepth(root->right);
              // 如果右子树为空，说明只需考虑左子树的深度
              if (!root->right)
                  return 1 + minDepth(root->left);
              // 如果左右子树都不为空，则分别求左右子树的深度，取最小值并加上根节点深度1
              return 1 + min(minDepth(root->left), minDepth(root->right));
          }
      };
      ```

   2. 



## [662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

1. 中等题啊，十分重要

2. 关键点在于，得补全为一个**完全二叉树** ，然后计算每一层的最左边和最右边的索引数减一.

3. 使用**宽搜** ，还有左子树右子树，进行计算。

4. ```cpp
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     TreeNode *left;
    *     TreeNode *right;
    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
    * };
    */
   class Solution {
   public:
       // Leetcode 662. Maximum Width of Binary Tree
       // @爱学习的饲养员
       // BFS
       // N is the size of Tree
       // Time Complexity: O(N)
       // Space Complexity: O(N)
       int widthOfBinaryTree(TreeNode* root) {
           if (root == nullptr)
               return 0;
   
           queue<TreeNode*> q;
           queue<unsigned long long> indexQ; // Use unsigned long long type
           unsigned long long result = 0;
           q.push(root);
           indexQ.push(1);
   
           while (!q.empty()) {
               int levelSize = q.size();
               unsigned long long initialIndex = indexQ.front();
               unsigned long long index = initialIndex;
               while (levelSize > 0) {
                   TreeNode* cur = q.front();
                   q.pop();
                   index = indexQ.front();
                   indexQ.pop();
                   if (cur != nullptr) {
                       if (cur->left != nullptr) {
                           q.push(cur->left);
                           indexQ.push(index * 2);
                       }
                       if (cur->right != nullptr) {
                           q.push(cur->right);
                           indexQ.push(index * 2 + 1);
                       }
                   }
                   levelSize--;
               }
               unsigned long long width = index - initialIndex + 1;
               result = max(result, width);
           }
   
           return result;
       }
   };
   ```

   



## [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)



1. ```cpp
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     TreeNode *left;
    *     TreeNode *right;
    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
    * };
    */
   class Solution {
   public:
       TreeNode* invertTree(TreeNode* root) {
           if (root == NULL) return root;
           stack<TreeNode*> st;
           st.push(root);
   
           while (!st.empty()) {
               TreeNode* node = st.top();
               st.pop();
               swap(node->left, node->right); // 就是也不用管它空不空，直接交换就可以了。
               if (node->right) st.push(node->right);
               if (node->left) st.push(node->left);
           }
           return root;
       }
   };
   ```



## [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)



1. ```cpp
   class Solution {
   public:
       bool isSymmetricNodes(TreeNode* leftNode, TreeNode* rightNode) {
           if (!leftNode && !rightNode) // 两个都是空
               return true;
           if (!leftNode || !rightNode) // 其中一个有，两个都有不行！
               return false;
           return (leftNode->val == rightNode->val) &&
                  isSymmetricNodes(leftNode->left, rightNode->right) &&
                  isSymmetricNodes(leftNode->right, rightNode->left);
   	}
       
       
       bool compare(TreeNode* left, TreeNode* right) {  // 
           if (left == NULL && right != NULL) return false;
           else if (left != NULL && right == NULL) return false;
           else if (left == NULL && right == NULL) return true;
           else if (left->val != right->val) return false;
   
           // 左右子树都不为空，并且值相同。
           bool inside = compare(left->right, right->left);
           bool outside = compare(right->right, left->left);
           return inside && outside;
       }
   
       bool isSymmetric(TreeNode* root) {
           if (root == nullptr ) return true;
           return compare(root->left, root->right);
       }
   };
   ```
   
2. ```cpp
   bool compare(TreeNode* left, TreeNode* right) {
       	if (!left && !right) return true; // 这一句话在前面，两个都是空
           if (!left || !right) return false; 
           
       /*
       if (!left && !right) return true; 这样就行了
           if (!left || !right) return false;*/
           if (left->val != right->val) return false;
           return compare(left->right, right->left) && compare(left->left, right->right);
       }
       bool isSymmetric(TreeNode* root) {
           if (!root) return true;
           return compare(root->left, root->right);
       }
   ```
   
3. 上面这样写不行啊！？



## [11. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

1. ```cpp
   /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     TreeNode *left;
    *     TreeNode *right;
    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
    * };
    */
   class Solution {
   public:
       int countNodes(TreeNode* root) {
           long long ans = 0;
           // vector<vector<int>> res;
           queue<TreeNode*> que;
           if (root == nullptr) return 0;
           que.push(root);
   
           while (!que.empty()) {
               int size = que.size();
               vector<int> vec;
               for (int i = 0; i < size; i++) {
                   TreeNode* node = que.front();
                   que.pop();
                   vec.push_back(node->val);
                   if (node->left) que.push(node->left);
                   if (node->right) que.push(node->right);
               }
               // res.push_back(vec);
               ans += vec.size();
           }
           return ans;
       }
   };
   ```

2. 

## 12.平衡二叉树

1. 求高度要用**后序遍历**，求深度，用先序遍历。

2. 高度是相对于最下面一层，所以要用后序遍历，如果左右子树都符合条件了，然后就可以加上根节点的（+1）

3. ```cpp
   class Solution {
   public:
       int getHeight(TreeNode* root) {
           if (root == nullptr) return 0;
           // 先看两个子树
           int leftHeight = getHeight(root->left); // 左
           if (leftHeight == -1) return -1;
           int rightHeight = getHeight(root->right); // 右
           if (rightHeight == -1) return -1;
   
           int result = 0;
           if (abs(leftHeight - rightHeight) > 1) result = -1; // 中，说明不平衡了。就没必要计算了。
           else {
               result = max(leftHeight, rightHeight) + 1;
           }
           return result;
       }
       bool isBalanced(TreeNode* root) {
           if (getHeight(root) == -1) {
               return false;
           } else {
               return true;
           }
       }
   };
   ```




## [13. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

1. 终止条件，就是收集到叶子结点。

2. 数组`vector` 转化为 `string` 

3. ```cpp
   // path不是全局最后的那个结果，所以不用引用。
   void binaryTreePathsHelper(TreeNode* root, string path, vector<string>& result) {
       // 如果节点为空，则直接返回
       if (!root)
           return;
   
       // 将当前节点的值添加到路径中
       path += to_string(root->val);
   
       // 如果当前节点是叶子节点，则将路径加入结果集中
       if (!root->left && !root->right) {
           result.push_back(path);
           return; // 开始找下一个路径
       }
   
       // 继续遍历左右子树
       path += "->";
       binaryTreePathsHelper(root->left, path, result);
       binaryTreePathsHelper(root->right, path, result);
   }
   
   vector<string> binaryTreePaths(TreeNode* root) {
       vector<string> result;
       binaryTreePathsHelper(root, "", result);
       return result;
   }
   ```



## [404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

0. <img src="../myNotes/h5200/images/image-20240318212951402.png" alt="image-20240318212951402" style="zoom:50%;" /> 

1. ```cpp
       long long sum = 0;
       bool isLeaf(TreeNode* root) {
           if (root == NULL) return false;
           if (root->left == NULL && root->right == NULL) return true;
           return false;
       }
       int sumOfLeftLeaves(TreeNode* root) {
           if (root == NULL) return 0;
           if (!root->left && !root->right) return 0;
           if (root->left && isLeaf(root->left)) sum += root->left->val;
           sumOfLeftLeaves(root->left);
           sumOfLeftLeaves(root->right);
           return sum;
       }
   ```

---

## [17. 路径总和](https://leetcode.cn/problems/path-sum/)

1. <img src="../myNotes/h5200/images/image-20240319160948462.png" alt="image-20240319160948462" style="zoom:50%;" /> 

2. ```cpp
   bool hasPathSum(TreeNode* root, int targetSum) {
       // 如果根节点为空，则不存在满足条件的路径 , 就是一个路径都没有了。
       if (!root) return false;
       
       // 如果当前节点是叶子节点，则判断当前节点值是否等于目标和
       if (!root->left && !root->right) {
           return targetSum == root->val;
       }
       // 递归检查左子树和右子树
       return hasPathSum(root->left, targetSum - root->val) ||  // 这就是向左走和向右走
              hasPathSum(root->right, targetSum - root->val);
   }
   ```



## [18. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)



## [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

- 对比 [面试题 04.12. 求和路径](https://leetcode.cn/problems/paths-with-sum-lcci/) （不要求从根节点开始）

1. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240319161840788.png" alt="image-20240319161840788" style="zoom:50%;" /> 

2. ```cpp
   void dfs(TreeNode* root, int targetSum, vector<vector<int>>& result, vector<int>& path) {
       if (!root) return;
       
       // 将当前节点值添加到路径中
       path.push_back(root->val);
       
       // 如果当前节点是叶子节点，且路径和等于目标和，则将当前路径添加到结果中
       if (!root->left && !root->right && targetSum == root->val) {
           result.push_back(path);
       }
       
       // 递归遍历左子树和右子树
       dfs(root->left, targetSum - root->val, result, path); // 从上一题的教训
       dfs(root->right, targetSum - root->val, result, path);
       
       // 回溯，将当前节点从路径中移除
       path.pop_back();
   }
   
   vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
       vector<vector<int>> result;
       vector<int> path;
       dfs(root, targetSum, result, path);
       return result;
   }
   ```



## [700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

1. ```cpp
       TreeNode* searchBST(TreeNode* root, int val) { // 找到一个值或者根节点不存在，就返回root
           if (!root ) return root;
           if (root->val == val) return root;
           else if (root->val > val) return searchBST(root->left, val);
           else {
               return searchBST(root->right, val);
           }
       }
   ```

2. 

##  [23. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

1. 中序序列是一个**生序序列** 

2. ```cpp
   class Solution {
   public:
       vector<int> vec;
       void traversal(TreeNode* root) {
           if (!root) return;
           traversal(root->left);
           vec.push_back(root->val);
           traversal(root->right);
       }
       bool isValidBST(TreeNode* root) {
           // 中序序列严格递增
           vec.clear(); // 清空一下
           traversal(root);
           for (int i = 1; i < vec.size(); i++) {
               if (vec[i] <= vec[i - 1]) return false;
           }
           return true;
       }
   };
   ```



## [24. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

1. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240319171556055.png" alt="image-20240319171556055" style="zoom:50%;" /> 

   

   ### 1. 直接转化为中序序列

   1. ```cpp
          void inorder(TreeNode* root, vector<int>& res) {
              if (!root) return;
              inorder(root->left, res);
              res.push_back(root->val);
              inorder(root->right, res);
          }
          int getMinimumDifference(TreeNode* root) {
              // 一般做法
              vector<int> res;
              inorder(root, res);
      
              int minn = INT_MAX;
              for (int i = 1; i < res.size(); i++) {
                  minn = min(minn, res[i] - res[i - 1]);
              }
              return minn;
          }
      ```



## [501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

1. ```cpp
       // 使用unordered_map
       // 先进行中序遍历
       void inorder(TreeNode* root, unordered_map<int, int>& mapp) {
           if (root == NULL) return;
           inorder(root->left, mapp);
           mapp[root->val] ++;
           inorder(root->right, mapp);
       }
   
       vector<int> findMode(TreeNode* root) {
        unordered_map<int, int> mapp; 
           inorder(root, mapp);
   
           // 找出现的最多的次数
           int maxFrequy = 0;
           for (const auto& m : mapp) {
               if (m.second > maxFrequy) maxFrequy = m.second;
           }
           vector<int> res;
           for (const auto& m : mapp) {
               if (m.second == maxFrequy) res.push_back(m.first);
           }
           return res;
       }
   ```



## [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

- <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240320151222927.png" alt="image-20240320151222927" style="zoom:50%;" /> 

1. ```cpp
   class Solution {
   public:
       TreeNode* sortedArrayToBST(vector<int>& nums) {
           if (nums.empty()) {
               return nullptr;
           }
           return sortedArrayToBST(nums, 0, nums.size() - 1);
       }
       
   private:
       TreeNode* sortedArrayToBST(vector<int>& nums, int left, int right) {
           if (left > right) { // 不符合二叉搜索树
               return nullptr;
           }
           
           // 取中间元素作为根节点
           int mid = left + (right - left) / 2;
           TreeNode* root = new TreeNode(nums[mid]);
           
           // 递归构建左右子树
           root->left = sortedArrayToBST(nums, left, mid - 1);
           root->right = sortedArrayToBST(nums, mid + 1, right);
           
           return root;
       }
   };
   ```



## [230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

1. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240320151731067.png" alt="image-20240320151731067" style="zoom:50%;" /> 

2. ```cpp
   class Solution {
   public:
       // 中序遍历吧
       vector<int> res;
       void traversal(TreeNode* root, vector<int>& res) {
           if (!root) return;
           traversal(root->left, res);
           res.push_back(root->val);
           traversal(root->right, res);
       }
       int kthSmallest(TreeNode* root, int k) {
           traversal(root, res);
           int i;
           for (i = 0; i < k - 1; i++);
           return res[i];
       }
   };
   ```



## [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

1. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240320153351992.png" alt="image-20240320153351992" style="zoom:50%;" /> 

2. ```cpp
   class Solution {
   public:
       // 寻找二叉搜索树中两个指定节点的最近公共祖先
       TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* , TreeNode* q) {
           if (!root) return nullptr; // 如果根节点为空，则返回空指针
   
           int root_val = root->val; // 获取根节点的值
           int p_val = p->val; // 获取第一个目标节点的值
           int q_val = q->val; // 获取第二个目标节点的值
   
           // 如果两个目标节点的值都小于根节点的值，则最近公共祖先在左子树中
           if (p_val < root_val && q_val < root_val) {
               return lowestCommonAncestor(root->left, p, q); // 递归搜索左子树
           } 
           // 如果两个目标节点的值都大于根节点的值，则最近公共祖先在右子树中
           else if (p_val > root_val && q_val > root_val) {
               return lowestCommonAncestor(root->right, p, q); // 递归搜索右子树
           } 
           // 否则，当前节点就是最近公共祖先, 就是p和q分别在两边
           else {
               return root;
           }
       }
   };
   ```



## [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

1. ```cpp
       TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
           // 如果根节点为空或者根节点等于p或q，则返回根节点
           if (!root || root == p || root == q) {
               return root;
           }
           
           // 在左子树中寻找p和q的最近公共祖先
           TreeNode* left = lowestCommonAncestor(root->left, p, q);
           // 在右子树中寻找p和q的最近公共祖先
           TreeNode* right = lowestCommonAncestor(root->right, p, q);
           
           // 如果左右子树都不为空，说明p和q分别在左右子树中，根节点即为最近公共祖先
           if (left && right) {
               return root;
           }
           
           // 如果左子树为空，则说明p和q都在右子树中
           if (!left) {
               return right;
           }
           
           // 如果右子树为空，则说明p和q都在左子树中
           return left;
       }
   ```

## [508. 出现次数最多的子树元素和](https://leetcode.cn/problems/most-frequent-subtree-sum/)

1. 给你一个二叉树的根结点 `root` ，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。

   一个结点的 **「子树元素和」** 定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。

2. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240320155209077.png" alt="image-20240320155209077" style="zoom:50%;" />

3. ```cpp
   class Solution {
   public:
       // 计算子树元素和
       int subtreeSum(TreeNode* root, std::unordered_map<int, int>& freq) {
           // 如果当前节点为空，则返回0
           if (!root) {
               return 0;
           }
           
           // 计算左子树的子树元素和
           int left_sum = subtreeSum(root->left, freq);
           // 计算右子树的子树元素和
           int right_sum = subtreeSum(root->right, freq);
           
           // 计算以当前节点为根的子树元素和
           int sum = root->val + left_sum + right_sum;
           // 更新频率统计表
           freq[sum]++;
           
           return sum;
       }
       
       // 寻找出现次数最多的子树元素和
       std::vector<int> findFrequentTreeSum(TreeNode* root) {
           std::unordered_map<int, int> freq; // 用于统计每个子树元素和的频率
           std::vector<int> result; // 存储结果
           
           // 计算子树元素和
           subtreeSum(root, freq);
           
           int max_freq = 0; // 最大频率
           
           // 找到最大频率
           for (const auto& entry : freq) {
               max_freq = std::max(max_freq, entry.second);
           }
           
           // 将所有出现次数最多的子树元素和加入结果集
           for (const auto& entry : freq) {
               if (entry.second == max_freq) {
                   result.push_back(entry.first);
               }
           }
           
           return result;
       }
   };
   ```

4. 



## [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

1. 远看是直径，实际上是，一个根节点的左子树和柚子树的最大深度的和；

2. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240320161919023.png" alt="image-20240320161919023" style="zoom:50%;" /> 

3. ```cpp
   class Solution {
   public:
       int diameterOfBinaryTree(TreeNode* root) {
           int diameter = 0; // 存储最长路径的长度
           calculateDiameter(root, diameter); // 计算最长路径的长度
           return diameter; // 返回直径
       }
       
       // 计算以当前节点为根的树的最大深度
       int calculateDepth(TreeNode* root) {
           if (!root) {
               return 0;
           }
           int left_depth = calculateDepth(root->left);
           int right_depth = calculateDepth(root->right);
           return std::max(left_depth, right_depth) + 1;
       }
       
       // 计算以当前节点为根的树的直径
       void calculateDiameter(TreeNode* root, int& diameter) {
           if (!root) {
               return;
           }
           
           // 计算左子树和右子树的深度
           int left_depth = calculateDepth(root->left);
           int right_depth = calculateDepth(root->right);
           
           // 更新最长路径的长度
           diameter = std::max(diameter, left_depth + right_depth);
           
           // 递归计算左子树和右子树的直径
           calculateDiameter(root->left, diameter);
           calculateDiameter(root->right, diameter);
       }
   };
   ```



## [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

1. 二叉树的**题目** ，主要就是，看成一个子树，节点啥的。

2. > 给你两棵二叉树： `root1` 和 `root2` 。
   >
   > 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。
   >
   > 返回合并后的二叉树。
   >
   > **注意:** 合并过程必须从两个树的根节点开始。

3. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240320162547132.png" alt="image-20240320162547132" style="zoom:50%;" /> 

4. ```cpp
   class Solution {
   public:
       TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
           // 如果其中一个树为空，则直接返回另一个树
           if (!root1) return root2;
           if (!root2) return root1;
           
           // 否则，将两棵树的节点值相加作为合并后节点的新值
           root1->val += root2->val;
           
           // 递归合并左子树和右子树
           root1->left = mergeTrees(root1->left, root2->left);
           root1->right = mergeTrees(root1->right, root2->right);
           
           return root1;
       }
   };
   ```



## [669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)

1. ![image-20240324122951233](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240324122951233.png) 

2. ```cpp
       TreeNode* trimBST(TreeNode* root, int low, int high) {
           // 如果根节点为空，则返回空
           if (!root) return nullptr;
   
           // 如果根节点的值小于 low，说明根节点及其左子树都不在修剪后的树中，递归修剪右子树，向右边走，找更大的。
           if (root->val < low) return trimBST(root->right, low, high);
           
           // 如果根节点的值大于 high，说明根节点及其右子树都不在修剪后的树中，递归修剪左子树
           if (root->val > high) return trimBST(root->left, low, high);
           
           // 如果根节点的值在 [low, high] 范围内，则修剪左右子树，并返回根节点
           // 就是更新修建过后的
           root->left = trimBST(root->left, low, high);
           root->right = trimBST(root->right, low, high);
           return root;
       }
   ```



## 给定两个序列构建一棵树（拿下！）





## [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)

0. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240324141006590.png" alt="image-20240324141006590" style="zoom:50%;" /> 

1. ```cpp
       bool isSubtree(TreeNode* root, TreeNode* subRoot) {
           if (!root) return false; // 如果根节点为空，返回false
           if (isSameTree(root, subRoot)) return true; // 如果当前根节点和子树根节点相同，返回true
           // 否则递归地检查左子树和右子树
           return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);
       }
       
       // 判断两棵树是否相同
       bool isSameTree(TreeNode* root1, TreeNode* root2) {
           if (!root1 && !root2) return true; // 如果两个根节点都为空，返回true
           if (!root1 || !root2) return false; // 如果其中一个根节点为空，返回false
           if (root1->val != root2->val) return false; // 如果根节点的值不相同，返回false
           // 递归判断左子树和右子树是否相同
           return isSameTree(root1->left, root2->left) && isSameTree(root1->right, root2->right);
       }
   ```



## [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

1. ![image-20240324142857787](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240324142857787.png) 

2. ```cpp
       int findBottomLeftValue(TreeNode* root) {
           vector<vector<int>> reslut;
           queue<TreeNode*> que;
           if (root != NULL) que.push(root);
   
           while (!que.empty()) {
               int size = que.size();
               vector<int> vec;
   
               for (int i = 0; i < size; i++) {
                   TreeNode* node = que.front();
                   que.pop();
                   vec.push_back(node->val);
                   if (node->left) que.push(node->left);
                   if (node->right) que.push(node->right);
               }
               reslut.push_back(vec);
           }
           return reslut.back().front();
       }
   ```

## [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

1. 给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

2. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240324144522123.png" alt="image-20240324144522123" style="zoom:50%;" /> 

3. ```cpp
       // 用于递归转换为累加树的辅助函数
       void convertBSTHelper(TreeNode* root, int& sum) {
           if (root == nullptr) return;
   
           // 遍历右子树
           convertBSTHelper(root->right, sum);
   
           // 更新节点值为累加和
           sum += root->val;
           root->val = sum;
   
           // 遍历左子树
           convertBSTHelper(root->left, sum);
       }
   
       // 主函数，转换为累加树
       TreeNode* convertBST(TreeNode* root) {
           int sum = 0;
           convertBSTHelper(root, sum);
           return root;
       }
   ```

4. > 1. `convertBSTHelper(root->right, sum);`：首先递归遍历右子树。因为二叉搜索树中，右子树的节点值都大于等于根节点的值，所以先处理右子树可以确保每个节点的值都是累加和的一部分。
   > 2. `sum += root->val;`：在遍历右子树之后，累加当前节点的值到 `sum` 中。这样做是为了将右子树中所有节点的值累加到 `sum` 中，从而确保当前节点的值为当前节点及其右子树节点值的和。
   > 3. `root->val = sum;`：更新当前节点的值为累加和。因为 `sum` 包含了当前节点及其右子树节点的值之和，所以将 `sum` 的值赋给当前节点，从而完成了累加树的转换。
   > 4. `convertBSTHelper(root->left, sum);`：最后递归遍历左子树。由于当前节点的值已经更新为其原值加上右子树节点值的累加和，所以再遍历左子树时，左子树节点的值也会受到右子树节点值的影响，从而确保了整棵树的累加和的正确性。



## 最大二叉树

1. 构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。



## [1379. 找出克隆二叉树中的相同节点](https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/)

1. 对于理解内存

2. my错误代码

   ```cpp
   class Solution {
   private:
       TreeNode* res;
       void traversal(TreeNode* original, TreeNode* cloned, TreeNode* target) {
           if (!original) return;
           if (original == target && cloned == target) {
               res = target;
               return;
           }
           traversal(original->left, cloned->left, target); 
           traversal(original->right, cloned->right, target); 
       }
   public:
       TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {
           traversal(original, cloned, target);
           return res;
       }
   };
   ```

3. ```cpp
   class Solution {
   private:
       TreeNode* res;
       void traversal(TreeNode* original, TreeNode* cloned, TreeNode* target) {
           if (!original || res) return; // 加入res不为空的判断条件,就是res已经有结果了
           if (original == target) { // 和原始的相同，返回，cloned
               res = cloned; // 更新结果为克隆树中对应的节点
               return;
           }
           traversal(original->left, cloned->left, target); 
           traversal(original->right, cloned->right, target); 
       }
   public:
       TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {
           traversal(original, cloned, target);
           return res;
       }
   };
   
   ```

4. 

## [2331. 计算布尔二叉树的值](https://leetcode.cn/problems/evaluate-boolean-binary-tree/)

1. ![image-20240401145035086](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401145035086.png)

2. ```cpp
   class Solution {
   public:
       bool evaluateTree(TreeNode* root) {
           // 如果左子树为空，则根节点值必须为 1
           if (root->left == nullptr) {
               return root->val == 1;
           }
           // 如果根节点值为 2，则左右子树只要有一个为 true，整个表达式就为 true
           if (root->val == 2) {
               return evaluateTree(root->left) || evaluateTree(root->right);
           }
           // 如果根节点值为 0 或 1，则左右子树都必须为 true，整个表达式才为 true
           // 也就是当前
           return evaluateTree(root->left) && evaluateTree(root->right);
       }
   };
   ```



## [897. 递增顺序搜索树](https://leetcode.cn/problems/increasing-order-search-tree/)

1. ![image-20240401172527338](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401172527338.png)

2. ```cpp
   class Solution {
   private:
       // 中序遍历
       vector<int> vec;
       void traversal(TreeNode* root) {
           if (!root) return;
           traversal(root->left);
           vec.push_back(root->val);
           traversal(root->right);
       }
   public:
       TreeNode* increasingBST(TreeNode* root) {
           traversal(root);
           TreeNode* dummy = new TreeNode(-1); // 空节点用于返回
           TreeNode* res = new TreeNode(0);
           dummy->left = nullptr;
           dummy->right = res;
   
           for (int i = 0; i < vec.size(); i++) {
               res->val = vec[i];
               res->left = nullptr;
               if (i != vec.size() - 1) {
                   res->right = new TreeNode(0);
                   res = res->right;
               }
           }
           return dummy->right;
       }
   };
   ```

2. 之后的解决方法
   
   ```cpp
   class Solution {
   private:
       std::vector<TreeNode*> vec;
   
       // 中序遍历，将节点存储在vec中
       void traversal(TreeNode* root) {
           if (!root) return;
           traversal(root->left);
           vec.push_back(root);
           traversal(root->right);
       }
   
   public:
       TreeNode* increasingBST(TreeNode* root) {
           traversal(root); // 中序遍历二叉树，将节点存储在vec中
           TreeNode* dummy = new TreeNode(-1);
           TreeNode* pre = dummy;
           for (auto it : vec) {
               it->left = nullptr; // 将左子树置空
               pre->right = it; // 更新前一个节点的右子树为当前节点
               pre = it; // 更新前一个节点
           }
           return dummy->right; // 返回dummy节点的右子树，即新的根节点
       }
   };
   
   ```
   
   
   
3. **关键是最后一步需要特殊处理一下** 

   <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401172629178.png" alt="image-20240401172629178" style="zoom:50%;" /> 

## [1022. 从根到叶的二进制数之和](https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/)

1. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401174200293.png" alt="image-20240401174200293" style="zoom:50%;" />

2. ```cpp
   class Solution {
   public:
       void sumRootToLeafHelper(TreeNode* root, vector<int> path, vector<vector<int>>& reslut) {
           if (!root) return;
           // 
           path.push_back(root->val);
           if (!root->left && !root->right) {
               reslut.push_back(path);
           }
           sumRootToLeafHelper(root->left, path, reslut);
           sumRootToLeafHelper(root->right, path, reslut);
       }
       // 给一个二进制数组，求表示的实际的数
       int getVal(vector<int> vec) {
           int sum = 0;
           for (int i = 0; i < vec.size(); i++) {
               if (vec[i]) sum += 1 << (vec.size() - 1 - i);
           }
           return sum;
       }
       int sumRootToLeaf(TreeNode* root) {
           vector<int> path;
           vector<vector<int>> reslut;
           sumRootToLeafHelper(root, path, reslut);
   
           long long int ans = 0;
           for (auto it : reslut) {
               ans += getVal(it);
           }
           return ans;
       }
   };
   ```

## [653. 两数之和 IV - 输入二叉搜索树](https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/)

1. 给定一个二叉搜索树 `root` 和一个目标结果 `k`，如果二叉搜索树中存在两个元素且它们的和等于给定的目标结果，则返回 `true`

2. ```cpp
   class Solution {
   private:
       vector<int> vec;
       // 求得中序遍历序列
       void traversal(TreeNode* root) {
           if (!root) return;
           traversal(root->left);
           vec.push_back(root->val);
           traversal(root->right);
       }
       bool hasSum(vector<int>& nums, int k) {
           unordered_set<int> seen;
           for (int num : nums) {
               int complement = k - num;
               if (seen.count(complement)) {
                   return true;
               }
               seen.insert(num); // 否则就把当前数加入到set
           }
           return false;
       }
   public:
       bool findTarget(TreeNode* root, int k) {
           traversal(root);
           return hasSum(vec, k);
       }
   };
   ```

3. 

## [872. 叶子相似的树](https://leetcode.cn/problems/leaf-similar-trees/)

1. ![image-20240401195255728](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401195255728.png) 

2. ```cpp
   class Solution {
   private:
       vector<int> vec;
       // 叶子结点
       bool isLeaf(TreeNode* root) {
           if (!root) return false;
           if (!root->left && !root->right) return true;
           return false;
       }
       // 前序遍历
       void traversal(TreeNode* root) {
           if (!root) return;
           if (isLeaf(root)) vec.push_back(root->val);
           traversal(root->left);
           traversal(root->right);
       }
   public:
       bool leafSimilar(TreeNode* root1, TreeNode* root2) {
           traversal(root1);
           vector<int> vec1 = vec; 
           vec.clear();
           traversal(root2);
           vector<int> vec2 = vec; 
           return vec1 == vec2;
       }
   };
   ```



## [993. 二叉树的堂兄弟节点](https://leetcode.cn/problems/cousins-in-binary-tree/)

1. 如果二叉树的两个节点深度相同，但 **父节点不同** ，则它们是一对*堂兄弟节点*。

   我们给出了具有唯一值的二叉树的根节点 `root` ，以及树中两个不同节点的值 `x` 和 `y` 。

   只有与值 `x` 和 `y` 对应的节点是堂兄弟节点时，才返回 `true` 。否则，返回 `false`。

2. <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401202114496.png" alt="image-20240401202114496" style="zoom:50%;" />

3. ```cpp
   class Solution {
   public:
       bool isCousins(TreeNode* root, int x, int y) {
           if (!root) return false;
           
           queue<TreeNode*> q;
           q.push(root);
           
           while (!q.empty()) {
               int size = q.size();
               bool foundX = false, foundY = false;
               for (int i = 0; i < size; ++i) {
                   TreeNode* node = q.front();
                   q.pop();
                   
                   if (node->val == x) foundX = true;
                   if (node->val == y) foundY = true;
                   
                   if (node->left && node->right) {
                       if ((node->left->val == x && node->right->val == y) ||
                           (node->left->val == y && node->right->val == x)) {
                           return false; // 如果 x 和 y 是兄弟节点，则返回 false
                       }
                   }
                   
                   if (node->left) {
                       q.push(node->left);
                   }
                   if (node->right) {
                       q.push(node->right);
                   }
               }
               
               if (foundX && foundY) {
                   return true; // 如果找到了 x 和 y，则返回 true
               } else if (foundX || foundY) {
                   return false; // 如果只找到了其中一个，则说明不是堂兄弟节点
               }
           }
           
           return false; // 如果在遍历过程中没有找到 x 和 y，则返回 false
       }
   };
   ```

## [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

- ![image-20240404104321832](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240404104321832.png) 

- ```cpp
  ```



## [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

1. 给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

   1. 创建一个根节点，其值为 `nums` 中的最大值。
   2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
   3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

   返回 *`nums` 构建的* ***最大二叉树\*** 。

2. ```cpp
   class Solution {
   public:
       int findMaxIndex(vector<int>& nums, int left, int right) {
           int maxIndex = left;
           for (int i = left + 1; i <= right; ++i) {
               if (nums[i] > nums[maxIndex]) {
                   maxIndex = i;
               }
           }
           return maxIndex;
       }
       
       TreeNode* construct(vector<int>& nums, int left, int right) {
           // left和right是下标，所以得小于
           if (left > right) return nullptr;
           
           int maxIndex = findMaxIndex(nums, left, right);
           TreeNode* root = new TreeNode(nums[maxIndex]);
           
           root->left = construct(nums, left, maxIndex - 1);
           root->right = construct(nums, maxIndex + 1, right);
           
           return root;
       }
   
       TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
           if (nums.empty()) return nullptr;
           return construct(nums, 0, nums.size() - 1);
       }
   };
   
   ```



## [1315. 祖父节点值为偶数的节点和](https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/)

- d

- ```cpp
  class Solution {
  public:
      // 返回满足条件的所有节点值之和
      int sumEvenGrandparent(TreeNode* root) {
          if (!root) return 0; // 如果根节点为空，则返回0
          return dfs(root, nullptr, nullptr); // 调用递归函数
      }
      
      // 递归函数，检查节点的祖父节点是否为偶数，并累加满足条件的节点值
      int dfs(TreeNode* node, TreeNode* parent, TreeNode* grandparent) {
          if (!node) return 0; // 如果节点为空，返回0
          
          int sum = 0; // 初始化累加和
          
          // 如果祖父节点存在且为偶数，则累加当前节点值
          if (grandparent && grandparent->val % 2 == 0) {
              sum += node->val;
          }
          
          // 递归遍历左右子树，并累加满足条件的节点值
          sum += dfs(node->left, node, parent);
          sum += dfs(node->right, node, parent);
          
          return sum; // 返回当前子树中满足条件的节点值之和
      }
  };
  
  ```

## [LCP 67. 装饰树](https://leetcode.cn/problems/KnLfVT/)

- ```cpp
  class Solution {
  public:
      // 返回新的插入节点
      // TreeNode* insertNode(TreeNode* parent) {
      //     if (!parent) return nullptr;
      //     TreeNode* newNode = new TreeNode(-1);
      //     parent->left = newNode
      // }
      void dfs(TreeNode* root) {
          if (!root) return;
          if (root->left) {
              TreeNode* newNode = new TreeNode(-1);
              TreeNode* tmp1 = root->left;
              root->left = newNode;
              newNode->left = tmp1;
              dfs(newNode->left);
          }
          // -----right
          if (root->right) {
              TreeNode* newNode = new TreeNode(-1);
              TreeNode* tmp2 = root->right;
              root->right = newNode;
              newNode->right = tmp2;
              dfs(newNode->right); // 这里不是root->right
          }
      }
      TreeNode* expandBinaryTree(TreeNode* root) {
          dfs(root);
          return root;
      }
  };
  ```



## [305. 两棵二叉搜索树中的所有元素](https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/)

- <img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240404152555628.png" alt="image-20240404152555628" style="zoom:50%;" /> 

- ```cpp
  class Solution {
  private:
      vector<int> vec1, vec2;
      void traversal(TreeNode* root, vector<int>& vec) {
          if (!root) return;
          traversal(root->left, vec);
          vec.push_back(root->val);
          traversal(root->right, vec);
      }
      vector<int> mergeVec(const vector<int>& vec1, const vector<int>& vec2) {
          vector<int> res;
          int i = 0, j = 0;
          while (i < vec1.size() && j < vec2.size()) {
              if (vec1[i] < vec2[j]) {
                  res.push_back(vec1[i++]);
              } else {
                  res.push_back(vec2[j++]);
              }
          }
          while (i < vec1.size()) {
              res.push_back(vec1[i++]);
          }
          while (j < vec2.size()) {
              res.push_back(vec2[j++]);
          }
          return res;
      }
  public:
      vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {
          traversal(root1, vec1);
          traversal(root2, vec2);
          vector<int> res = mergeVec(vec1, vec2);
          return res;
      }
  };
  ```



## [2415. 反转二叉树的奇数层](https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/)

- ```cpp
  class Solution {
  public:
      TreeNode* reverseOddLevels(TreeNode* root) {
          if (!root) return nullptr;
  
          queue<TreeNode*> que;
          que.push(root);
          int level = 0; // 从第一层开始
          while (!que.empty()) {
              int size = que.size();
              vector<int> vec1;
              vector<TreeNode*> vec2;
              for (int i = 0; i < size; i++) {
                  TreeNode* node = que.front();
                  que.pop();
                  vec1.push_back(node->val); // 将当前层的节点值存入 values 数组
                  vec2.push_back(node);
                  if (node->left) que.push(node->left);
                  if (node->right) que.push(node->right);
              }
              if (level % 2 == 1) {
                  reverse(vec1.begin(), vec1.end());
                  int index = 0; // 标记vec1
                  for (auto node : vec2) {
                      node->val = vec1[index++];
                  }
              }
              level++;
          }
          return root;
      }
  };
  
  ```



## [1448. 统计二叉树中好节点的数目](https://leetcode.cn/problems/count-good-nodes-in-binary-tree/)

- 为什么这里函数curMax不用引用？

  在这种情况下，我们不需要将curMax作为引用传递给dfs函数，因为我们不需要在dfs函数中修改调用者的curMax变量。在每次调用dfs函数时，我们都会传递一个新的curMax值，这个值是当前节点值和父节点的curMax值中较大的那个。在dfs函数内部，我们只需要使用这个新值来判断当前节点是否是好节点，并且在递归调用dfs函数时，将这个新值传递给下一层的子节点即可。

  因此，我们不需要在dfs函数中修改调用者的curMax变量，也不需要通过引用传递来实现这个功能。相反，我们只需在每次调用dfs函数时传递一个新的curMax值，这样就可以正确地在整个二叉树上计算好节点的数量。

# 图



## 拓扑排序

## 408的24年真题

1. ```cpp
   #include <iostream>
   #include <vector>
   #include <queue>
   
   using namespace std;
   
   // 有向图的表示
   vector<vector<int>> adj;
   
   // 计算每个节点的入度
   vector<int> computeIndegree(int n) {
       vector<int> indegree(n, 0);
       for (int i = 0; i < n; ++i) {
           for (int j : adj[i]) {
               indegree[j]++;
           }
       }
       return indegree;
   }
   
   // 拓扑排序
   vector<int> topologicalSort(int n) {
       vector<int> indegree = computeIndegree(n);
       vector<int> order;
       queue<int> q;
   
       // 将入度为0的节点加入队列
       for (int i = 0; i < n; ++i) {
           if (indegree[i] == 0) {
               q.push(i);
           }
       }
   
       // 依次弹出入度为0的节点，并更新相关节点的入度
       while (!q.empty()) {
           int node = q.front();
           q.pop();
           order.push_back(node);
           for (int neighbor : adj[node]) {
               indegree[neighbor]--;
               if (indegree[neighbor] == 0) {
                   q.push(neighbor);
               }
           }
       }
   
       // 如果有环，则返回空序列
       if (order.size() != n) {
           return {};
       }
       return order;
   }
   
   // 打印拓扑排序序列
   void printTopologicalSort(int n) {
       vector<int> order = topologicalSort(n);
       if (order.empty()) {
           cout << "There is no unique topological order!" << endl;
       } else {
           cout << "Topological order(s):" << endl;
           do {
               for (int node : order) {
                   cout << node << " ";
               }
               cout << endl;
           } while (next_permutation(order.begin(), order.end()));
       }
   }
   
   int main() {
       // 读取图的节点数和边数
       int n, m;
       cout << "Enter the number of nodes and edges: ";
       cin >> n >> m;
   
       // 初始化邻接表
       adj.resize(n);
   
       // 读取边的信息
       cout << "Enter the edges (node_i node_j):" << endl;
       for (int i = 0; i < m; ++i) {
           int u, v;
           cin >> u >> v;
           adj[u].push_back(v);
       }
   
       // 输出拓扑排序序列
       printTopologicalSort(n);
   
       return 0;
   }
   
   ```

2. 已知图G采用邻接矩阵存储，试判断G是否有唯一的拓扑排序序列，如果有返回1否则返回0，使用cpp编程并给出注释，还要求给出G的结构体定义。

   ```cpp
   #include <iostream>
   #include <vector>
   
   // 定义图的结构体
   struct Graph {
       std::vector<std::vector<int>> adjMatrix; // 邻接矩阵存储图的边信息
       int numVertices; // 图中顶点的数量
   
       // 构造函数
       Graph(int n) : numVertices(n) {
           // 初始化邻接矩阵为全零
           adjMatrix.resize(n, std::vector<int>(n, 0));
       }
   };
   
   class Solution {
   public:
       // 拓扑排序函数
       bool topologicalSort(Graph& G) {
           std::vector<int> inDegree(G.numVertices, 0); // 存储每个顶点的入度
           int count = 0; // 记录已经排序的顶点数量
   
           // 统计每个顶点的入度
           for (int i = 0; i < G.numVertices; ++i) {
               for (int j = 0; j < G.numVertices; ++j) {
                   if (G.adjMatrix[i][j] == 1) {
                       inDegree[j]++;
                   }
               }
           }
   
           // 使用队列存储入度为0的顶点
           std::vector<int> queue;
           for (int i = 0; i < G.numVertices; ++i) {
               if (inDegree[i] == 0) {
                   queue.push_back(i);
               }
           }
   
           // 开始拓扑排序
           while (!queue.empty()) {
               int node = queue.front();
               queue.erase(queue.begin());
               ++count;
   
               // 更新与该顶点相邻的顶点的入度
               for (int i = 0; i < G.numVertices; ++i) {
                   if (G.adjMatrix[node][i] == 1) {
                       if (--inDegree[i] == 0) {
                           queue.push_back(i);
                       }
                   }
               }
           }
   
           // 如果拓扑排序后的顶点数量与图中的顶点数量相等，说明有唯一的拓扑排序序列
           return count == G.numVertices;
       }
   };
   
   int main() {
       // 创建图的实例并初始化
       Graph G(5); // 假设有5个顶点的图
   
       // 假设图的邻接矩阵如下所示（这里只展示了一种可能的情况，实际应用中需要根据具体情况填写邻接矩阵）
       // 0 1 1 0 0
       // 0 0 0 1 1
       // 0 0 0 0 0
       // 0 0 0 0 0
       // 0 0 0 0 0
       G.adjMatrix = {{0, 1, 1, 0, 0},
                      {0, 0, 0, 1, 1},
                      {0, 0, 0, 0, 0},
                      {0, 0, 0, 0, 0},
                      {0, 0, 0, 0, 0}};
   
       // 创建Solution对象
       Solution solution;
       // 判断是否有唯一的拓扑排序序列
       bool uniqueTopoSort = solution.topologicalSort(G);
   
       // 输出结果
       std::cout << "The graph has a unique topological sorting sequence: " << uniqueTopoSort << std::endl;
   
       return 0;
   }
   
   ```

   

## [785. 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/)

1. ```cpp
   class Solution {
   public:
       bool isBipartite(vector<vector<int>>& graph) {
           int n = graph.size();
           vector<int> colors(n, 0); // 记录每个节点的颜色，0 表示未染色，1 表示染成第一种颜色，-1 表示染成第二种颜色
   
           // 使用 BFS 遍历图
           for (int i = 0; i < n; ++i) {
               if (colors[i] != 0) continue; // 如果节点已经染色，跳过
   
               // BFS 遍历以 i 为起始节点的连通分量
               queue<int> q;
               q.push(i);
               colors[i] = 1; // 将起始节点染成第一种颜色
   
               while (!q.empty()) {
                   int node = q.front();
                   q.pop();
   
                   // 遍历当前节点的所有邻接节点
                   for (int neighbor : graph[node]) {
                       if (colors[neighbor] == 0) { // 如果邻接节点未染色
                           colors[neighbor] = -colors[node]; // 将其染成与当前节点不同的颜色, 
                           q.push(neighbor); // 入队
                       } else if (colors[neighbor] == colors[node]) { // 如果邻接节点的颜色与当前节点相同，说明不是二分图
                           return false;
                       }
                       // 如果邻接节点的颜色与当前节点不同，则继续遍历
                   }
               }
           }
   
           return true; // 如果能够完成染色，并且没有出现颜色冲突，则说明是二分图
       }
   };
   ```

2. ` colors[neighbor] = -colors[node]; // 将其染成与当前节点不同的颜色, ` 不可以直接染成2，只要是不同就可以了





## [207. 课程表](https://leetcode.cn/problems/course-schedule/)

1. 深度优先遍历

2. ```cpp
   class Solution {
   public:
       bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
           vector<vector<int>> adj(numCourses, vector<int>());
           vector<int> inDegree(numCourses, 0);
   
           // 构建邻接表和入度数组
           for (auto& pre : prerequisites) {
               adj[pre[1]].push_back(pre[0]);
               inDegree[pre[0]]++;
           }
   
           // 将入度为 0 的节点加入队列
           queue<int> q;
           for (int i = 0; i < numCourses; ++i) {
               if (inDegree[i] == 0) {
                   q.push(i);
               }
           }
   
           // 使用拓扑排序进行课程学习顺序的判断
           while (!q.empty()) {
               int course = q.front(); // 当前的课程。neighbor,当前的课程可以到达的课程号。
               q.pop();
               numCourses--;
   
               for (int neighbor : adj[course]) {
                   if (--inDegree[neighbor] == 0) { // 刚好有一个前置课程,这个边可以划去
                       q.push(neighbor);
                   }
               }
           }
   
           return numCourses == 0;
       }
   };
   ```

## [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

- 现在你总共有 `numCourses` 门课需要选，记为 `0` 到 `numCourses - 1`。给你一个数组 `prerequisites` ，其中 `prerequisites[i] = [ai, bi]` ，表示在选修课程 `ai` 前 **必须** 先选修 `bi` 。

  - 例如，想要学习课程 `0` ，你需要先完成课程 `1` ，我们用一个匹配来表示：`[0,1]` 。

  返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 **任意一种** 就可以了。如果不可能完成所有课程，返回 **一个空数组** 。

1. ```cpp
   class Solution {
   public:
       vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
           int n = numCourses;
           vector<vector<int>> adj(n, vector<int>());
           vector<int> inDegree(n);
   
           for (auto& pre : prerequisites) {
               adj[pre[1]].push_back(pre[0]);
               inDegree[pre[0]]++;
           }
   
           queue<int> q;
           for (int i = 0; i < n; i++) {
               if (inDegree[i] == 0) {
                   q.push(i);
               }
           }
   
           // topsort（）
           vector<int> res;
           while (!q.empty()) {
               int course = q.front();
               res.push_back(course);
               q.pop();
   
               for (auto neighbor : adj[course]) {
                   if (--inDegree[neighbor] == 0) {
                       q.push(neighbor);
                   }
               }
           }
           for (int i = 0; i < n; i++) { // 一旦有入度不为0的，说明没有消去完全，不存在拓扑排序
               if (inDegree[i] != 0) {
                   return vector<int>();
               }
           }
           return res;
       }
   };
   ```



## [LeetCode 1059. 从始点到终点的所有路径（回溯）](https://cloud.tencent.com/developer/article/1787958)





## [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/)

- 树可以看成是一个连通且 **无环** 的 **无向** 图。

  给定往一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后的图。添加的边的两个顶点包含在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。

  请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的那个。

- ![image-20240403122535566](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240403122535566.png) 

- ```cpp
  class Solution {
  public:
      // 找到节点所属的集合，使用路径压缩优化
      int Find(vector<int>& parent, int index) {
          // 如果节点的父节点不是自己，说明还没有找到根节点，继续向上找
          if (parent[index] != index) {
              // 使用递归方式找到根节点，并将当前节点的父节点指向根节点
              parent[index] = Find(parent, parent[index]);
          }
          // 返回当前节点所属的根节点
          return parent[index];
      }
  
      // 合并两个节点所属的集合，按秩合并
      void Union(vector<int>& parent, int index1, int index2) {
          // 找到两个节点所在的集合的根节点
          int root1 = Find(parent, index1);
          int root2 = Find(parent, index2);
          // 将其中一个根节点指向另一个根节点，实现集合的合并
          parent[root1] = root2;
      }
  
      // 寻找多余的连接
      vector<int> findRedundantConnection(vector<vector<int>>& edges) {
          int n = edges.size(); // 边的数量
          vector<int> parent(n + 1); // 保存每个节点的父节点，初始时每个节点的父节点为自己
          for (int i = 1; i <= n; ++i) {
              parent[i] = i; // 初始化每个节点的父节点为自己
          }
          for (auto& edge: edges) { // 遍历每条边
              int node1 = edge[0], node2 = edge[1]; // 获取边连接的两个节点
              // 如果这两个节点不在同一个集合中，则合并这两个集合
              if (Find(parent, node1) != Find(parent, node2)) {
                  Union(parent, node1, node2);
              } else {
                  // 如果这两个节点已经在同一个集合中，说明这条边是多余的，直接返回该边
                  return edge;
              }
          }
          // 如果没有找到多余的连接，则返回空的vector
          return vector<int>{};
      }
  };
  
  ```

- ```cpp
  class Solution {
  private:
      int p[1010];
      int find(int x) {
          if (x != p[x]) {
              p[x] = find(p[x]);
          }
          return p[x];
      }
          
  public:
      vector<int> findRedundantConnection(vector<vector<int>>& edges) {
          int n = edges.size();
          for (int i = 1; i <= n; i++) {
              p[i] = i;
          }
          for (auto& it : edges) {
              int a = it[0];
              int b = it[1];
              if (find(a) != find(b)) {
                  p[find(a)] = find(b);
              } else {
                  return it;
              }
          }
          return vector<int>();
      }
  };
  ```

## [LCR 116. 省份数量](https://leetcode.cn/problems/bLyHh0/)

- ```cpp
  class Solution {
  private:
          int find(vector<int>& p, int x) {
              if (x != p[x]) {
                  p[x] = find(p, p[x]);
              }
              return p[x];
          }
  
  public:
      int findCircleNum(vector<vector<int>>& isConnected) {
          int n = isConnected.size();
          vector<int> p(n + 1); // 第一个空出来
  
          for (int i = 1; i <= n; i++) p[i] = i;
          // 只便利上半部分
          for (int i = 0; i < n; i++) {
              for (int j = i + 1; j < n; j++) {
                  if (isConnected[i][j] == 1) {
                      int a = i + 1;
                      int b = j + 1;
                      if (find(p, a) != find(p, b)) {
                          p[find(p, a)] = find(p, b);
                      }
                  }
              }
          }
          // 最后看p里面有几个不同的值
          // unordered_set<int> set;
          // for (int i = 1; i <= n; i++) set.insert(p[i]);
          // return set.size();
          int count = 0;
          for (int i = 1; i <= n; i++) {
              if (p[i] == i) { // 还是这个i号集合，所以可以
                  count++;
              }
          }
          return count;
      }
  };
  ```



## [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)

1. ```cpp
   class Solution {
   public:
       const int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
       int dfs(vector<vector<int>>& grid, int x, int y) {
           if (x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() 
               || grid[x][y] == 0) {
                   return 0;
           }
           int area = 1;
           grid[x][y] = 0;
           for (int k = 0; k < 4; k++) {
               int a = x + dx[k];
               int b = y + dy[k];
               area += dfs(grid, a, b);
           }
           return area;
       }
       int maxAreaOfIsland(vector<vector<int>>& grid) {
           int ans = 0;
           int m = grid.size();
           int n = grid[0].size();
           for (int i = 0; i < m; i++) {
               for (int j = 0; j < n; j++) {
                   ans = max(ans, dfs(grid, i, j));
               }
           }
           return ans;
       }
   };
   ```
   
2. 记忆化搜索

   ```cpp
   #include <vector>
   #include <algorithm>
   
   using namespace std;
   
   class Solution {
   private:
       int m, n;
       vector<vector<int>> memo;
   
       int dfs(vector<vector<int>>& grid, int i, int j) {
           if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0 || memo[i][j] == 1) {
               return 0;
           }
           memo[i][j] = 1; // 走过了
           int area = 1;
           area += dfs(grid, i + 1, j);
           area += dfs(grid, i - 1, j);
           area += dfs(grid, i, j + 1);
           area += dfs(grid, i, j - 1);
           return area;
       }
   
   public:
       int maxAreaOfIsland(vector<vector<int>>& grid) {
           m = grid.size();
           n = grid[0].size();
           memo.assign(m, vector<int>(n, 0));
           int maxArea = 0;
           for (int i = 0; i < m; ++i) {
               for (int j = 0; j < n; ++j) {
                   if (grid[i][j] == 1 && memo[i][j] == 0) {
                       maxArea = max(maxArea, dfs(grid, i, j));
                   }
               }
           }
           return maxArea;
       }
   };
   
   ```

   



## [1267. 统计参与通信的服务器](https://leetcode.cn/problems/count-servers-that-communicate/)

1. 这里有一幅服务器分布图，服务器的位置标识在 `m * n` 的整数矩阵网格 `grid` 中，1 表示单元格上有服务器，0 表示没有。

   如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。

   请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。

2. 总的 - 不能通信的（这一行一列就有一个服务器）

- ```cpp
  
  class Solution {
      public int countServers(int[][] grid) {
  
          //先计算总共有多少服务器 allCount
          //再计算不能通信的服务器数量 badCount
          //能够通信的服务器goodCount=allCount-badCount
  
          //如果计算不能通信的服务器，某一行只有一个服务器并且该服务器对应的列也只有一台服务器
  
  
  
  
          int  allCount=0;
          int badCount=0;
  
          int pointA=0;
  
          //计算总共有多少服务器
          for(int i=0;i<grid.length;i++){
  
              //行和
              int sumC=0;
              //列和
              int sumA=0;
              for(int j=0;j<grid[i].length;j++){
                  if(grid[i][j]==1){
                      allCount++;
                      sumC++;
                      //记录对应的列的下标
                      pointA=j;
                  }
              }
              if(sumC==1){
  
                  for(int k=0;k<grid.length;k++){
                      //说明该行只有一个服务器
                      if(grid[k][pointA]==1){
                      sumA++;
                      }
                  }
                  if(sumA==1){
                      badCount++;
                  }
                  
              }
  
              
  
          }
  
          return allCount-badCount;
  
  
  
  
  
      }
  }
  ```

- 
